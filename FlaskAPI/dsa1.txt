['chapter 1  introduction  these lecture notes cover the key ideas involved in designing algorithms', ' we shall see how they depend on the design of suitable data structures, and how some structures and algorithms are more eﬃcient than others for the same task', ' we will concentrate on a few basic tasks, such as storing, sorting and searching data, that underlie much of computer science, but the techniques discussed will be applicable much more generally', '  we will start by studying some key data structures, such as arrays, lists, queues, stacks and trees, and then move on to explore their use in a range of diﬀerent searching and sorting algorithms', ' this leads on to the consideration of approaches for more eﬃcient storage of data in hash tables', ' finally, we will look at graph based representations and cover the kinds of algorithms needed to work eﬃciently with them', ' throughout, we will investigate the computational eﬃciency of the algorithms we develop, and gain intuitions about the pros and cons of the various potential approaches for each task', '  we will not restrict ourselves to implementing the various data structures and algorithms in particular computer programming languages (e', 'g', ', java, c , ocaml ), but specify them in simple pseudocode that can easily be implemented in any appropriate language', '  1', '1 algorithms as opposed to programs  an algorithm for a particular task can be deﬁned as “a ﬁnite sequence of instructions, each of which has a clear meaning and can be performed with a ﬁnite amount of eﬀort in a ﬁnite length of time”', ' as such, an algorithm must be precise enough to be understood by human beings', ' however, in order to be executed by a computer, we will generally need a program that is written in a rigorous formal language; and since computers are quite inﬂexible compared to the human mind, programs usually need to contain more details than algorithms', ' here we shall ignore most of those programming details and concentrate on the design of algorithms rather than programs', '  the task of implementing the discussed algorithms as computer programs is important, of course, but these notes will concentrate on the theoretical aspects and leave the practical programming aspects to be studied elsewhere', ' having said that, we will often ﬁnd it useful to write down segments of actual programs in order to clarify and test certain theoretical aspects of algorithms and their data structures', ' it is also worth bearing in mind the distinction between diﬀerent programming paradigms: imperative programming describes computation in terms of instructions that change the program/data state, whereas declarative programming  5  \x0cspeciﬁes what the program should accomplish without describing how to do it', ' these notes will primarily be concerned with developing algorithms that map easily onto the imperative programming approach', '  algorithms can obviously be described in plain english, and we will sometimes do that', ' however, for computer scientists it is usually easier and clearer to use something that comes somewhere in between formatted english and computer program code, but is not runnable because certain details are omitted', ' this is called pseudocode, which comes in a variety of forms', ' often these notes will present segments of pseudocode that are very similar to the languages we are mainly interested in, namely the overlap of c and java, with the advantage that they can easily be inserted into runnable programs', '  1', '2 fundamental questions about algorithms  given an algorithm to solve a particular problem, we are naturally led to ask:  1', ' what is it supposed to do?  2', ' does it really do what it is supposed to do?  3', ' how eﬃciently does it do it?  the technical terms normally used for these three aspects are:  1', ' speciﬁcation', '  2', ' veriﬁcation', '  3', ' performance analysis', '  the details of these three aspects will usually be rather problem dependent', '  the speciﬁcation should formalize the crucial details of the problem that the algorithm is intended to solve', ' sometimes that will be based on a particular representation of the associated data, and sometimes it will be presented more abstractly', ' typically, it will have to specify how the inputs and outputs of the algorithm are related, though there is no general requirement that the speciﬁcation is complete or non-ambiguous', '  for simple problems, it is often easy to see that a particular algorithm will always work, i', 'e', ' that it satisﬁes its speciﬁcation', ' however, for more complicated speciﬁcations and/or algorithms, the fact that an algorithm satisﬁes its speciﬁcation may not be obvious at all', ' in this case, we need to spend some eﬀort verifying whether the algorithm is indeed correct', ' in general, testing on a few particular inputs can be enough to show that the algorithm is incorrect', ' however, since the number of diﬀerent potential inputs for most algorithms is inﬁnite in theory, and huge in practice, more than just testing on particular cases is needed to be sure that the algorithm satisﬁes its speciﬁcation', ' we need correctness proofs', ' although we will discuss proofs in these notes, and useful relevant ideas like invariants, we will usually only do so in a rather informal manner (though, of course, we will attempt to be rigorous)', ' the reason is that we want to concentrate on the data structures and algorithms', ' formal veriﬁcation techniques are complex and will normally be left till after the basic ideas of these notes have been studied', '  finally, the eﬃciency or performance of an algorithm relates to the resources required by it, such as how quickly it will run, or how much computer memory it will use', ' this will  6  \x0cusually depend on the problem instance size, the choice of data representation, and the details of the algorithm', ' indeed, this is what normally drives the development of new data structures and algorithms', ' we shall study the general ideas concerning eﬃciency in chapter 5, and then apply them throughout the remainder of these notes', '  1', '3 data structures, abstract data types, design patterns  for many problems, the ability to formulate an eﬃcient algorithm depends on being able to organize the data in an appropriate manner', ' the term data structure is used to denote a particular way of organizing data for particular types of operation', ' these notes will look at numerous data structures ranging from familiar arrays and lists to more complex structures such as trees, heaps and graphs, and we will see how their choice aﬀects the eﬃciency of the algorithms based upon them', '  often we want to talk about data structures without having to worry about all the im- plementational details associated with particular programming languages, or how the data is stored in computer memory', ' we can do this by formulating abstract mathematical models of particular classes of data structures or data types which have common features', ' these are called abstract data types, and are deﬁned only by the operations that may be performed on them', ' typically, we specify how they are built out of more primitive data types (e', 'g', ', integers or strings), how to extract that data from them, and some basic checks to control the ﬂow of processing in algorithms', ' the idea that the implementational details are hidden from the user and protected from outside access is known as encapsulation', ' we shall see many examples of abstract data types throughout these notes', '  at an even higher level of abstraction are design patterns which describe the design of algorithms, rather the design of data structures', ' these embody and generalize important design concepts that appear repeatedly in many problem contexts', ' they provide a general structure for algorithms, leaving the details to be added as required for particular problems', ' these can speed up the development of algorithms by providing familiar proven algorithm structures that can be applied straightforwardly to new problems', ' we shall see a number of familiar design patterns throughout these notes', '  1', '4 textbooks and web-resources  to fully understand data structures and algorithms you will almost certainly need to comple- ment the introductory material in these notes with textbooks or other sources of information', ' the lectures associated with these notes are designed to help you understand them and ﬁll in some of the gaps they contain, but that is unlikely to be enough because often you will need to see more than one explanation of something before it can be fully understood', '  there is no single best textbook that will suit everyone', ' the subject of these notes is a classical topic, so there is no need to use a textbook published recently', ' books published 10 or 20 years ago are still good, and new good books continue to be published every year', ' the reason is that these notes cover important fundamental material that is taught in all university degrees in computer science', ' these days there is also a lot of very useful information to be found on the internet, including complete freely-downloadable books', ' it is a good idea to go to your library and browse the shelves of books on data structures and algorithms', ' if you like any of them, download, borrow or buy a copy for yourself, but make sure that most of the  7  \x0ctopics in the above contents list are covered', ' wikipedia is generally a good source of fairly reliable information on all the relevant topics, but you hopefully shouldn’t need reminding that not everything you read on the internet is necessarily true', ' it is also worth pointing out that there are often many diﬀerent equally-good ways to solve the same task, diﬀerent equally-sensible names used for the same thing, and diﬀerent equally-valid conventions used by diﬀerent people, so don’t expect all the sources of information you ﬁnd to be an exact match with each other or with what you ﬁnd in these notes', '  1', '5 overview  these notes will cover the principal fundamental data structures and algorithms used in computer science, and bring together a broad range of topics covered elsewhere into a coherent framework', ' data structures will be formulated to represent various types of information in such a way that it can be conveniently and eﬃciently manipulated by the algorithms we develop', ' throughout, the recurring practical issues of algorithm speciﬁcation, veriﬁcation and performance analysis will be discussed', '  we shall begin by looking at some widely used basic data structures (namely arrays, linked lists, stacks and queues), and the advantages and disadvantages of the associated abstract data types', ' then we consider the ubiquitous problem of searching, and how that leads on to the general ideas of computational eﬃciency and complexity', ' that will leave us with the necessary tools to study three particularly important data structures: trees (in particular, binary search trees and heap trees), hash tables, and graphs', ' we shall learn how to develop and analyse increasingly eﬃcient algorithms for manipulating and performing useful operations on those structures, and look in detail at developing eﬃcient processes for data storing, sorting, searching and analysis', ' the idea is that once the basic ideas and examples covered in these notes are understood, dealing with more complex problems in the future should be straightforward', '  8  \x0cchapter 2  arrays, iteration, invariants  data is ultimately stored in computers as patterns of bits, though these days most program- ming languages deal with higher level objects, such as characters, integers, and ﬂoating point numbers', ' generally, we need to build algorithms that manipulate collections of such objects, so we need procedures for storing and sequentially processing them', '  2', '1 arrays  in computer science, the obvious way to store an ordered collection of items is as an array', ' array items are typically stored in a sequence of computer memory locations, but to discuss them, we need a convenient way to write them down on paper', ' we can just write the items in order, separated by commas and enclosed by square brackets', ' thus,  is an example of an array of integers', ' if we call this array a, we can write it as:  [1, 4, 17, 3, 90, 79, 4, 6, 81]  a = [1, 4, 17, 3, 90, 79, 4, 6, 81]  this array a has 9 items, and hence we say that its size is 9', ' in everyday life, we usually start counting from 1', ' when we work with arrays in computer science, however, we more often (though not always) start from 0', ' thus, for our array a, its positions are 0, 1, 2, ', ' ', ' ', ' , 7, 8', ' the element in the 8th position is 81, and we use the notation a[8] to denote this element', ' more generally, for any integer i denoting a position, we write a[i] to denote the element in the ith position', ' this position i is called an index (and the plural is indices)', ' then, in the above example, a[0] = 1, a[1] = 4, a[2] = 17, and so on', '  it is worth noting at this point that the symbol = is quite overloaded ', ' in mathematics, it stands for equality', ' in most modern programming languages, = denotes assignment, while equality is expressed by ==', ' we will typically use = in its mathematical meaning, unless it is written as part of code or pseudocode', '  we say that the individual items a[i] in the array a are accessed using their index i, and one can move sequentially through the array by incrementing or decrementing that index, or jump straight to a particular item given its index value', ' algorithms that process data stored as arrays will typically need to visit systematically all the items in the array, and apply appropriate operations on them', '  9  \x0c2', '2 loops and iteration  the standard approach in most programming languages for repeating a process a certain number of times, such as moving sequentially through an array to perform the same operations on each item, involves a loop', ' in pseudocode, this would typically take the general form  and in programming languages like c and java this would be written as the for-loop  for i = 1,', '', '', ',n,  do something  for( i = 0 ; i < n ; i++ ) {  // do something  }  }  }  in which a counter i keep tracks of doing “the something” n times', ' for example, we could compute the sum of all 20 items in an array a using  for( i = 0, sum = 0 ; i < 20 ; i++ ) {  sum += a[i];  we say that there is iteration over the index i', ' the general for-loop structure is  for( initialization ; condition ; update ) {  repeated process  in which any of the four parts are optional', ' one way to write this out explicitly is  initialization if ( not condition ) go to loop finished loop start  repeated process update if ( condition ) go to loop start  loop finished  in these notes, we will regularly make use of this basic loop structure when operating on data stored in arrays, but it is important to remember that diﬀerent programming languages use diﬀerent syntax, and there are numerous variations that check the condition to terminate the repetition at diﬀerent points', '  2', '3  invariants  an invariant, as the name suggests, is a condition that does not change during execution of a given program or algorithm', ' it may be a simple inequality, such as “i < 20”, or something more abstract, such as “the items in the array are sorted”', ' invariants are important for data structures and algorithms because they enable correctness proofs and veriﬁcation', '  in particular, a loop-invariant is a condition that is true at the beginning and end of every iteration of the given loop', ' consider the standard simple example of a procedure that ﬁnds the minimum of n numbers stored in an array a:  10  \x0cminimum(int n, float a[n]) {  float min = a[0]; // min equals the minimum item in a[0],', '', '', ',a[0] for(int i = 1 ; i != n ; i++) {  // min equals the minimum item in a[0],', '', '', ',a[i-1] if (a[i] < min) min = a[i];  } // min equals the minimum item in a[0],', '', '', ',a[i-1], and i==n return min;  }  at the beginning of each iteration, and end of any iterations before, the invariant “min equals the minimum item in a[0], ', '', '', ', a[i − 1]” is true – it starts oﬀ true, and the repeated process and update clearly maintain its truth', ' hence, when the loop terminates with “i == n”, we know that “min equals the minimum item in a[0], ', '', '', ', a[n − 1]” and hence we can be sure that min can be returned as the required minimum value', ' this is a kind of proof by induction: the invariant is true at the start of the loop, and is preserved by each iteration of the loop, therefore it must be true at the end of the loop', '  as we noted earlier, formal proofs of correctness are beyond the scope of these notes, but identifying suitable loop invariants and their implications for algorithm correctness as we go along will certainly be a useful exercise', ' we will also see how invariants (sometimes called inductive assertions) can be used to formulate similar correctness proofs concerning properties of data structures that are deﬁned inductively', '  11  \x0cchapter 3  lists, recursion, stacks, queues  we have seen how arrays are a convenient way to store collections of items, and how loops and iteration allow us to sequentially process those items', ' however, arrays are not always the most eﬃcient way to store collections of items', ' in this section, we shall see that lists may be a better way to store collections of items, and how recursion may be used to process them', ' as we explore the details of storing collections as lists, the advantages and disadvantages of doing so for diﬀerent situations will become apparent', '  3', '1 linked lists  a list can involve virtually anything, for example, a list of integers [3, 2, 4, 2, 5], a shopping list [apples, butter, bread, cheese], or a list of web pages each containing a picture and a link to the next web page', ' when considering lists, we can speak about-them on diﬀerent levels - on a very abstract level (on which we can deﬁne what we mean by a list), on a level on which we can depict lists and communicate as humans about them, on a level on which computers can communicate, or on a machine level in which they can be implemented', '  graphical representation  non-empty lists can be represented by two-cells, in each of which the ﬁrst cell contains a pointer to a list element and the second cell contains a pointer to either the empty list or another two-cell', ' we can depict a pointer to the empty list by a diagonal bar or cross through the cell', ' for instance, the list [3, 1, 4, 2, 5] can be represented as:  (cid:45)  (cid:45)  (cid:45)  (cid:45)  (cid:63)  3  (cid:63)  1  (cid:63)  4  (cid:63)  2  (cid:0)  (cid:0)  (cid:0)  (cid:63)  5  abstract data type “list”  on an abstract level , a list can be constructed by the two constructors:  • emptylist, which gives you the empty list, and  12  \x0c• makelist(element, list), which puts an element at the top of an existing list', '  using those, our last example list can be constructed as  makelist(3, makelist(1, makelist(4, makelist(2, makelist(5, emptylist)))))', '  and it is clearly possible to construct any list in this way', '  this inductive approach to data structure creation is very powerful, and we shall use it many times throughout these notes', ' it starts with the “base case”, the emptylist, and then builds up increasingly complex lists by repeatedly applying the “induction step”, the makelist(element, list) operator', '  it is obviously also important to be able to get back the elements of a list, and we no longer have an item index to use like we have with an array', ' the way to proceed is to note that a list is always constructed from the ﬁrst element and the rest of the list', ' so, conversely, from a non-empty list it must always be possible to get the ﬁrst element and the rest', ' this can be done using the two selectors, also called accessor methods:  • first(list), and  • rest(list)', '  • isempty(list)  the selectors will only work for non-empty lists (and give an error or exception on the empty list), so we need a condition which tells us whether a given list is empty:  this will need to be used to check every list before passing it to a selector', '  we call everything a list that can be constructed by the constructors emptylist and makelist, so that with the selectors first and rest and the condition isempty, the following relationships are automatically satisﬁed (i', 'e', ' true):  • isempty(emptylist)  • not isempty(makelist(x, l)) (for any x and l)  • first(makelist(x, l)) = x  • rest(makelist(x, l)) = l  in addition to constructing and getting back the components of lists, one may also wish to destructively change lists', ' this would be done by so-called mutators which change either the ﬁrst element or the rest of a non-empty list:  • replacefirst(x, l)  • replacerest(r, l)  for instance, with l = [3, 1, 4, 2, 5], applying replacefirst(9, l) changes l to [9, 1, 4, 2, 5]', ' and then applying replacerest([6, 2, 3, 4], l) changes it to [9, 6, 2, 3, 4]', '  we shall see that the concepts of constructors, selectors and conditions are common to virtually all abstract data types', ' throughout these notes, we will be formulating our data representations and algorithms in terms of appropriate deﬁnitions of them', '  13  \x0cxml representation  in order to communicate data structures between diﬀerent computers and possibly diﬀerent programming languages, xml (extensible markup language) has become a quasi-standard', ' the above list could be represented in xml as:  however, there are usually many diﬀerent ways to represent the same object in xml', ' for instance, a cell-oriented representation of the above list would be:  <ol>  <li>3</li> <li>1</li> <li>4</li> <li>2</li> <li>5</li>  </ol>  <cell>  <first>3</first> <rest>  <cell>  <first>1</first> <rest>  <cell>  <first>4</first> <rest>  <cell>  <first>2</first> <rest>  <first>5</first> <rest>emptylist</rest>  </rest>  </cell>  </rest>  </cell>  </rest>  </cell>  </rest>  </cell>  while this looks complicated for a simple list, it is not, it is just a bit lengthy', ' xml is ﬂexible enough to represent and communicate very complicated structures in a uniform way', '  implementation of lists  there are many diﬀerent implementations possible for lists, and which one is best will depend on the primitives oﬀered by the programming language being used', '  the programming language lisp and its derivates, for instance, take lists as the most important primitive data structure', ' in some other languages, it is more natural to implement  14  \x0clists as arrays', ' however, that can be problematic because lists are conceptually not limited in size, which means array based implementation with ﬁxed-sized arrays can only approximate the general concept', ' for many applications, this is not a problem because a maximal number of list members can be determined a priori (e', 'g', ', the maximum number of students taking one particular module is limited by the total number of students in the university)', ' more general purpose implementations follow a pointer based approach, which is close to the diagrammatic representation given above', ' we will not go into the details of all the possible implementations of lists here, but such information is readily available in the standard textbooks', '  3', '2 recursion  we previously saw how iteration based on for-loops was a natural way to process collections of items stored in arrays', ' when items are stored as linked-lists, there is no index for each item, and recursion provides the natural way to process them', ' the idea is to formulate procedures which involve at least one step that invokes (or calls) the procedure itself', ' we will now look at how to implement two important derived procedures on lists, last and append, which illustrate how recursion works', '  to ﬁnd the last element of a list l we can simply keep removing the ﬁrst remaining item  till there are no more left', ' this algorithm can be written in pseudocode as:  last(l) {  if ( isempty(l) )  error(‘error: empty list in last’)  elseif ( isempty(rest(l)) )  return first(l)  else  }  return last(rest(l))  the running time of this depends on the length of the list, and is proportional to that length, since last is called as often as there are elements in the list', ' we say that the procedure has linear time complexity, that is, if the length of the list is increased by some factor, the execution time is increased by the same factor', ' compared to the constant time complexity which access to the last element of an array has, this is quite bad', ' it does not mean, however, that lists are inferior to arrays in general, it just means that lists are not the ideal data structure when a program has to access the last element of a long list very often', '  another useful procedure allows us to append one list l2 to another list l1', ' again, this needs to be done one item at a time, and that can be accomplished by repeatedly taking the ﬁrst remaining item of l1 and adding it to the front of the remainder appended to l2:  append(l1,l2) {  if ( isempty(l1) )  return l2  else  }  return makelist(first(l1),append(rest(l1),l2))  the time complexity of this procedure is proportional to the length of the ﬁrst list, l1, since we have to call append as often as there are elements in l1', '  15  \x0c3', '3 stacks  stacks are, on an abstract level, equivalent to linked lists', ' they are the ideal data structure to model a first-in-last-out (filo), or last-in-first-out (lifo), strategy in search', '  graphical representation  their relation to linked lists means that their graphical representation can be the same, but one has to be careful about the order of the items', ' for instance, the stack created by inserting the numbers [3, 1, 4, 2, 5] in that order would be represented as:  (cid:45)  (cid:45)  (cid:45)  (cid:45)  (cid:63)  5  (cid:63)  2  (cid:63)  4  (cid:63)  1  (cid:0)  (cid:0)  (cid:0)  (cid:63)  3  abstract data type “stack”  despite their relation to linked lists, their diﬀerent use means the primitive operators for stacks are usually given diﬀerent names', ' the two constructors are:  • emptystack, the empty stack, and  • push(element, stack), which takes an element and pushes it on top of an existing stack,  and the two selectors are:  • top(stack), which gives back the top most element of a stack, and  • pop(stack), which gives back the stack without the top most element', '  the selectors will work only for non-empty stacks, hence we need a condition which tells whether a stack is empty:  • isempty(stack)  we have equivalent automatically-true relationships to those we had for the lists:  • isempty(emptystack)  • not isempty(push(x, s)) (for any x and s)  • top(push(x, s)) = x  • pop(push(x, s)) = s  in summary, we have the direct correspondences:  constructors  selectors  list stack  emptylist emptystack  makelist push  first top  rest pop  condition isempty isempty  so, stacks and linked lists are the same thing, apart from the diﬀerent names that are used for their constructors and selectors', '  16  \x0cimplementation of stacks  there are two diﬀerent ways we can think about implementing stacks', ' so far we have implied a functional approach', ' that is, push does not change the original stack, but creates a new stack out of the original stack and a new element', ' that is, there are at least two stacks around, the original one and the newly created one', ' this functional view is quite convenient', ' if we apply top to a particular stack, we will always get the same element', ' however, from a practical point of view, we may not want to create lots of new stacks in a program, because of the obvious memory management implications', ' instead it might be better to think of a single stack which is destructively changed, so that after applying push the original stack no longer exits, but has been changed into a new stack with an extra element', ' this is conceptually more diﬃcult, since now applying top to a given stack may give diﬀerent answers, depending on how the state of the system has changed', ' however, as long as we keep this diﬀerence in mind, ignoring such implementational details should not cause any problems', '  3', '4 queues  a queue is a data structure used to model a first-in-first-out (fifo) strategy', ' conceptually, we add to the end of a queue and take away elements from its front', '  graphical representation  a queue can be graphically represented in a similar way to a list or stack, but with an additional two-cell in which the ﬁrst element points to the front of the list of all the elements in the queue, and the second element points to the last element of the list', ' for instance, if we insert the elements [3, 1, 4, 2] into an initially empty queue, we get:  (cid:63)  (cid:63)  3  (cid:45)  (cid:45)  (cid:45)  (cid:63)  1  (cid:63)  4  (cid:0)  (cid:0)  (cid:0)  (cid:63)  (cid:63)  2  this arrangement means that taking the ﬁrst element of the queue, or adding an element to the back of the queue, can both be done eﬃciently', ' in particular, they can both be done with constant eﬀort, i', 'e', ' independently of the queue length', '  abstract data type “queue”  on an abstract level, a queue can be constructed by the two constructors:  • emptyqueue, the empty queue, and  • push(element, queue), which takes an element and a queue and returns a queue in which  the element is added to the original queue at the end', '  for instance, by applying push(5, q) where q is the queue above, we get  17  \x0c(cid:63)  (cid:63)  (cid:45)  (cid:45)  (cid:45)  (cid:45)  (cid:63)  (cid:63)  4 the two selectors are the same as for stacks:  3  1  (cid:63)  2  (cid:0)  (cid:0)  (cid:0)  (cid:63)  (cid:63)  5  • top(queue), which gives the top element of a queue, that is, 3 in the example, and  • pop(queue), which gives the queue without the top element', '  and, as with stacks, the selectors only work for non-empty queues, so we again need a condi- tion which returns whether a queue is empty:  • isempty(queue)  in later chapters we shall see practical examples of how queues and stacks operate with diﬀerent eﬀect', '  3', '5 doubly linked lists  a doubly linked list might be useful when working with something like a list of web pages, which has each page containing a picture, a link to the previous page, and a link to the next page', ' for a simple list of numbers, a linked list and a doubly linked list may look the same, e', 'g', ', [3, 1, 4, 2, 5]', ' however, the doubly linked list also has an easy way to get the previous element, as well as to the next element', '  graphical representation  non-empty doubly linked lists can be represented by three-cells, where the ﬁrst cell contains a pointer to another three-cell or to the empty list, the second cell contains a pointer to the list element and the third cell contains a pointer to another three-cell or the empty list', ' again, we depict the empty list by a diagonal bar or cross through the appropriate cell', ' for instance, [3, 1, 4, 2, 5] would be represented as doubly linked list as:  (cid:0)(cid:0)  (cid:0)  (cid:27) (cid:45)  (cid:63)  3  (cid:63)  1  (cid:27) (cid:45)  (cid:27) (cid:45)  (cid:27) (cid:45)  (cid:63)  2  (cid:0)  (cid:0)  (cid:0)  (cid:63)  5  abstract data type “doubly linked list”  on an abstract level , a doubly linked list can be constructed by the three constructors:  • emptylist, the empty list, and  (cid:63)  4  18  \x0c• makelistleft(element, list), which takes an element and a doubly linked list and returns a new doubly linked list with the element added to the left of the original doubly linked list', '  • makelistright(element, list), which takes an element and a doubly linked list and returns a new doubly linked list with the element added to the right of the original doubly linked list', '  it is clear that it may possible to construct a given doubly linked list in more that one way', ' for example, the doubly linked list represented above can be constructed by either of:  makelistleft(3, makelistleft(1, makelistleft(4, makelistleft(2,  makelistleft(5, emptylist)))))  makelistleft(3, makelistleft(1, makelistright(5, makelistright(2,  makelistleft(4, emptylist)))))  in the case of doubly linked lists, we have four selectors:  then, since the selectors only work for non-empty lists, we also need a condition which returns whether a list is empty:  • firstleft(list),  • restleft(list),  • firstright(list), and  • restright(list)', '  this leads to automatically-true relationships such as:  • isempty(list)  • isempty(emptylist)  • not isempty(makelistleft(x, l)) (for any x and l)  • not isempty(makelistright(x, l)) (for any x and l)  • firstleft(makelistleft(x, l)) = x  • restleft(makelistleft(x, l)) = l  • firstright(makelistright(x, l)) = x  • restright(makelistright(x, l)) = l  circular doubly linked list  as a simple extension of the standard doubly linked list, one can deﬁne a circular doubly linked list in which the left-most element points to the right-most element, and vice versa', ' this is useful when we might need to move eﬃciently through a whole list of items, but might not be starting from one of two particular end points', '  19  \x0c3', '6 advantage of abstract data types  it is clear that the implementation of the abstract linked-list data type has the disadvantage that certain useful procedures may not be directly accessible', ' for instance, the standard abstract data type of a list does not oﬀer an eﬃcient procedure last(l) to give the last element in the list, whereas it would be trivial to ﬁnd the last element of an array of a known number of elements', ' one could modify the linked-list data type by maintaining a pointer to the last item, as we did for the queue data type, but we still wouldn’t have an easy way to access intermediate items', ' while last(l) and getitem(i, l) procedures can easily be implemented using the primitive constructors, selectors, and conditions, they are likely to be less eﬃcient than making use of certain aspects of the underlying implementation', '  that disadvantage leads to an obvious question: why should we want to use abstract data types when they often lead to less eﬃcient algorithms? aho, hopcroft and ullman (1983) provide a clear answer in their book:  “at ﬁrst, it may seem tedious writing procedures to govern all accesses to the underlying structures', ' however, if we discipline ourselves to writing programs in terms of the operations for manipulating abstract data types rather than mak- ing use of particular implementations details, then we can modify programs more readily by reimplementing the operations rather than searching all programs for places where we have made accesses to the underlying data structures', ' this ﬂexi- bility can be particularly important in large software eﬀorts, and the reader should not judge the concept by the necessarily tiny examples found in this book', '”  this advantage will become clearer when we study more complex abstract data types and algorithms in later chapters', '  20  \x0cchapter 4  searching  an important and recurring problem in computing is that of locating information', ' more succinctly, this problem is known as searching', ' this is a good topic to use for a preliminary exploration of the various issues involved in algorithm design', '  4', '1 requirements for searching  clearly, the information to be searched has to ﬁrst be represented (or encoded ) somehow', ' this is where data structures come in', ' of course, in a computer, everything is ultimately represented as sequences of binary digits (bits), but this is too low level for most purposes', ' we need to develop and study useful data structures that are closer to the way humans think, or at least more structured than mere sequences of bits', ' this is because it is humans who have to develop and maintain the software systems – computers merely run them', '  after we have chosen a suitable representation, the represented information has to be processed somehow', ' this is what leads to the need for algorithms', ' in this case, the process of interest is that of searching', ' in order to simplify matters, let us assume that we want to search a collection of integer numbers (though we could equally well deal with strings of characters, or any other data type of interest)', ' to begin with, let us consider:  1', ' the most obvious and simple representation', '  2', ' two potential algorithms for processing with that representation', '  as we have already noted, arrays are one of the simplest possible ways of representing col- lections of numbers (or strings, or whatever), so we shall use that to store the information to be searched', ' later we shall look at more complex data structures that may make storing and searching more eﬃcient', '  suppose, for example, that the set of integers we wish to search is {1,4,17,3,90,79,4,6,81}', '  we can write them in an array a as  a = [1, 4, 17, 3, 90, 79, 4, 6, 81]  if we ask where 17 is in this array, the answer is 2, the index of that element', ' if we ask where 91 is, the answer is nowhere', ' it is useful to be able to represent nowhere by a number that is not used as a possible index', ' since we start our index counting from 0, any negative number would do', ' we shall follow the convention of using the number −1 to represent nowhere', ' other (perhaps better) conventions are possible, but we will stick to this here', '  21  \x0c4', '2 speciﬁcation of the search problem  we can now formulate a speciﬁcation of our search problem using that data structure:  given an array a and integer x, ﬁnd an integer i such that  1', ' if there is no j such that a[j] is x, then i is −1,  2', ' otherwise, i is any j for which a[j] is x', '  the ﬁrst clause says that if x does not occur in the array a then i should be −1, and the second says that if it does occur then i should be a position where it occurs', ' if there is more than one position where x occurs, then this speciﬁcation allows you to return any of them – for example, this would be the case if a were [17, 13, 17] and x were 17', ' thus, the speciﬁcation is ambiguous', ' hence diﬀerent algorithms with diﬀerent behaviours can satisfy the same speciﬁcation – for example, one algorithm may return the smallest position at which x occurs, and another may return the largest', ' there is nothing wrong with ambiguous speciﬁcations', ' in fact, in practice, they occur quite often', '  4', '3 a simple algorithm: linear search  we can conveniently express the simplest possible algorithm in a form of pseudocode which reads like english, but resembles a computer program without some of the precision or detail that a computer usually requires:  // this assumes we are given an array a of size n and a key x', ' for i = 0,1,', '', '', ',n-1,  if a[i] is equal to x,  if we reach this point,  then we have a suitable i and can terminate returning i', '  then x is not in a and hence we must terminate returning -1', '  some aspects, such as the ellipsis “', ' ', ' ', ' ”, are potentially ambiguous, but we, as human beings, know exactly what is meant, so we do not need to worry about them', ' in a programming language such as c or java, one would write something that is more precise like:  for ( i = 0 ; i < n ; i++ ) {  if ( a[i] == x ) return i;  } return -1;  in the case of java, this would be within a method of a class, and more details are needed, such as the parameter a for the method and a declaration of the auxiliary variable i', ' in the case of c , this would be within a function, and similar missing details are needed', ' in either, there would need to be additional code to output the result in a suitable format', '  in this case, it is easy to see that the algorithm satisﬁes the speciﬁcation (assuming n is the correct size of the array) – we just have to observe that, because we start counting from zero, the last position of the array is its size minus one', ' if we forget this, and let i run from 0 to n instead, we get an incorrect algorithm', ' the practical eﬀect of this mistake is that the execution of this algorithm gives rise to an error when the item to be located in the array is  22  \x0cactually not there, because a non-existing location is attempted to be accessed', ' depending on the particular language, operating system and machine you are using, the actual eﬀect of this error will be diﬀerent', ' for example, in c running under unix, you may get execution aborted followed by the message “segmentation fault”, or you may be given the wrong answer as the output', ' in java, you will always get an error message', '  4', '4 a more eﬃcient algorithm: binary search  one always needs to consider whether it is possible to improve upon the performance of a particular algorithm, such as the one we have just created', ' in the worst case, searching an array of size n takes n steps', ' on average, it will take n/2 steps', ' for large collections of data, such as all web-pages on the internet, this will be unacceptable in practice', ' thus, we should try to organize the collection in such a way that a more eﬃcient algorithm is possible', ' as we shall see later, there are many possibilities, and the more we demand in terms of eﬃciency, the more complicated the data structures representing the collections tend to become', ' here we shall consider one of the simplest – we still represent the collections by arrays, but now we enumerate the elements in ascending order', ' the problem of obtaining an ordered list from any given list is known as sorting and will be studied in detail in a later chapter', '  thus, instead of working with the previous array [1, 4, 17, 3, 90, 79, 4, 6, 81], we would work with [1, 3, 4, 4, 6, 17, 79, 81, 90], which has the same items but listed in ascending order', ' then we can use an improved algorithm, which in english-like pseudocode form is:  // this assumes we are given a sorted array a of size n and a key x', ' // use integers left and right (initially set to 0 and n-1) and mid', ' while left is less than right,  set mid to the integer part of (left+right)/2, and if x is greater than a[mid],  then otherwise set right to mid', '  set left to mid+1,  if a[left] is equal to x,  then otherwise terminate returning -1', '  terminate returning left,  and would correspond to a segment of c or java code like:  /* data */ int a = [1,3,4,4,6,17,79,81,90]; int n = 9; int x = 79; /* program */ int left = 0, right = n-1, mid; while ( left < right ) {  mid = ( left + right ) / 2; if ( x > a[mid] ) left = mid+1; else right = mid;  } if ( a[left] == x ) return left; else return -1;  23  \x0cthis algorithm works by repeatedly splitting the array into two segments, one going from lef t to mid, and the other going from mid + 1 to right, where mid is the position half way from lef t to right, and where, initially, lef t and right are the leftmost and rightmost positions of the array', ' because the array is sorted, it is easy to see which of each pair of segments the searched-for item x is in, and the search can then be restricted to that segment', ' moreover, because the size of the sub-array going from locations lef t to right is halved at each iteration of the while-loop, we only need log2 n steps in either the average or worst case', ' to see that this runtime behaviour is a big improvement, in practice, over the earlier linear-search algorithm, notice that log2 1000000 is approximately 20, so that for an array of size 1000000 only 20 iterations are needed in the worst case of the binary-search algorithm, whereas 1000000 are needed in the worst case of the linear-search algorithm', '  with the binary search algorithm, it is not so obvious that we have taken proper care of the boundary condition in the while loop', ' also, strictly speaking, this algorithm is not correct because it does not work for the empty array (that has size zero), but that can easily be ﬁxed', ' apart from that, is it correct? try to convince yourself that it is, and then try to explain your argument-for-correctness to a colleague', ' having done that, try to write down some convincing arguments, maybe one that involves a loop invariant and one that doesn’t', ' most algorithm developers stop at the ﬁrst stage, but experience shows that it is only when we attempt to write down seemingly convincing arguments that we actually ﬁnd all the subtle mistakes', ' moreover, it is not unusual to end up with a better/clearer algorithm after it has been modiﬁed to make its correctness easier to argue', '  it is worth considering whether linked-list versions of our two algorithms would work, or oﬀer any advantages', ' it is fairly clear that we could perform a linear search through a linked list in essentially the same way as with an array, with the relevant pointer returned rather than an index', ' converting the binary search to linked list form is problematic, because there it seems that our array-based is no eﬃcient way to split a linked list into two segments', ' approach is the best we can do with the data structures we have studied so far', ' however, we shall see later how more complex data structures (trees) can be used to formulate eﬃcient recursive search algorithms', '  notice that we have not yet taken into account how much eﬀort will be required to sort the array so that the binary search algorithm can work on it', ' until we know that, we cannot be sure that using the binary search algorithm really is more eﬃcient overall than using the linear search algorithm on the original unsorted array', ' that may also depend on further details, such as how many times we need to performa a search on the set of n items – just once, or as many as n times', ' we shall return to these issues later', ' first we need to consider in more detail how to compare algorithm eﬃciency in a reliable manner', '  24  \x0cchapter 5  eﬃciency and complexity  we have already noted that, when developing algorithms, it is important to consider how eﬃcient they are, so we can make informed choices about which are best to use in particular circumstances', ' so, before moving on to study increasingly complex data structures and algorithms, we ﬁrst look in more detail at how to measure and describe their eﬃciency', '  5', '1 time versus space complexity  when creating software for serious applications, there is usually a need to judge how quickly an algorithm or program can complete the given tasks', ' for example, if you are programming a ﬂight booking system, it will not be considered acceptable if the travel agent and customer have to wait for half an hour for a transaction to complete', ' it certainly has to be ensured that the waiting time is reasonable for the size of the problem, and normally faster execution is better', ' we talk about the time complexity of the algorithm as an indicator of how the execution time depends on the size of the data structure', '  another important eﬃciency consideration is how much memory a given program will require for a particular task, though with modern computers this tends to be less of an issue than it used to be', ' here we talk about the space complexity as how the memory requirement depends on the size of the data structure', '  for a given task, there are often algorithms which trade time for space, and vice versa', ' for example, we will see that, as a data storage device, hash tables have a very good time complexity at the expense of using more memory than is needed by other algorithms', ' it is usually up to the algorithm/program designer to decide how best to balance the trade-oﬀ for the application they are designing', '  5', '2 worst versus average complexity  another thing that has to be decided when making eﬃciency considerations is whether it is the average case performance of an algorithm/program that is important, or whether it is more important to guarantee that even in the worst case the performance obeys certain rules', ' for many applications, the average case is more important, because saving time overall is usually more important than guaranteeing good behaviour in the worst case', ' however, for time-critical problems, such as keeping track of aeroplanes in certain sectors of air space, it may be totally unacceptable for the software to take too long if the worst case arises', '  25  \x0cagain, algorithms/programs often trade-oﬀ eﬃciency of the average case against eﬃciency of the worst case', ' for example, the most eﬃcient algorithm on average might have a par- ticularly bad worst case eﬃciency', ' we will see particular examples of this when we consider eﬃcient algorithms for sorting and searching', '  5', '3 concrete measures for performance  these days, we are mostly interested in time complexity', ' for this, we ﬁrst have to decide how to measure it', ' something one might try to do is to just implement the algorithm and run it, and see how long it takes to run, but that approach has a number of problems', ' for one, if it is a big application and there are several potential algorithms, they would all have to be programmed ﬁrst before they can be compared', ' so a considerable amount of time would be wasted on writing programs which will not get used in the ﬁnal product', ' also, the machine on which the program is run, or even the compiler used, might inﬂuence the running time', ' you would also have to make sure that the data with which you tested your program is typical for the application it is created for', ' again, particularly with big applications, this is not really feasible', ' this empirical method has another disadvantage: it will not tell you anything useful about the next time you are considering a similar problem', '  therefore complexity is usually best measured in a diﬀerent way', ' first, in order to not be bound to a particular programming language or machine architecture, it is better to measure the eﬃciency of the algorithm rather than that of its implementation', ' for this to be possible, however, the algorithm has to be described in a way which very much looks like the program to be implemented, which is why algorithms are usually best expressed in a form of pseudocode that comes close to the implementation language', '  what we need to do to determine the time complexity of an algorithm is count the number of times each operation will occur, which will usually depend on the size of the problem', ' the size of a problem is typically expressed as an integer, and that is typically the number of items that are manipulated', ' for example, when describing a search algorithm, it is the number of items amongst which we are searching, and when describing a sorting algorithm, it is the number of items to be sorted', ' so the complexity of an algorithm will be given by a function which maps the number of items to the (usually approximate) number of time steps the algorithm will take when performed on that many items', '  in the early days of computers, the various operations were each counted in proportion to their particular ‘time cost’, and added up, with multiplication of integers typically considered much more expensive than their addition', ' in today’s world, where computers have become much faster, and often have dedicated ﬂoating-point hardware, the diﬀerences in time costs have become less important', ' however, we still we need to be careful when deciding to consider all operations as being equally costly – applying some function, for example, can take much longer than simply adding two numbers, and swaps generally take many times longer than comparisons', ' just counting the most costly operations is often a good strategy', '  5', '4 big-o notation for complexity class  very often, we are not interested in the actual function c(n) that describes the time complex- ity of an algorithm in terms of the problem size n, but just its complexity class', ' this ignores any constant overheads and small constant factors, and just tells us about the principal growth  26  \x0cof the complexity function with problem size, and hence something about the performance of the algorithm on large numbers of items', '  if an algorithm is such that we may consider all steps equally costly, then usually the complexity class of the algorithm is simply determined by the number of loops and how often the content of those loops are being executed', ' the reason for this is that adding a constant number of instructions which does not change with the size of the problem has no signiﬁcant eﬀect on the overall complexity for large problems', '  there is a standard notation, called the big-o notation, for expressing the fact that constant factors and other insigniﬁcant details are being ignored', ' for example, we saw that the procedure last(l) on a list l had time complexity that depended linearly on the size n of the list, so we would say that the time complexity of that algorithm is o(n)', ' similarly, linear search is o(n)', ' for binary search, however, the time complexity is o(log2 n)', '  before we deﬁne complexity classes in a more formal manner, it is worth trying to gain some intuition about what they actually mean', ' for this purpose, it is useful to choose one function as a representative of each of the classes we wish to consider', ' recall that we are considering functions which map natural numbers (the size of the problem) to the set of non- negative real numbers r+, so the classes will correspond to common mathematical functions such as powers and logarithms', ' we shall consider later to what degree a representative can be considered ‘typical’ for its class', '  the most common complexity classes (in increasing order) are the following:  • o(1), pronounced ‘oh of one’, or constant complexity;  • o(log2 log2 n), ‘oh of log log en’;  • o(log2 n), ‘oh of log en’, or logarithmic complexity;  • o(n), ‘oh of en’, or linear complexity;  • o(nlog2 n), ‘oh of en log en’;  • o(n2), ‘oh of en squared’, or quadratic complexity;  • o(n3), ‘oh of en cubed’, or cubic complexity;  • o(2n), ‘oh of two to the en’, or exponential complexity', '  as a representative, we choose the function which gives the class its name – e', 'g', ' for o(n) we choose the function f (n) = n, for o(log2 n) we choose f (n) = log2 n, and so on', ' so assume we have algorithms with these functions describing their complexity', ' the following table lists how many operations it will take them to deal with a problem of a given size:  f (n) 1 log2 log2 n log2 n n nlog2 n n2 n3 2n  n = 4 n = 16 1 2 4 16 64 256 4096 65536  1 1 2 4 8 16 64 16  n = 256 1 3 8 2', '56 × 102 2', '05 × 103 6', '55 × 104 1', '68 × 107 1', '16 × 1077  27  n = 1024 1', '00 × 100 3', '32 × 100 1', '00 × 101 1', '02 × 103 1', '02 × 104 1', '05 × 106 1', '07 × 109 1', '80 × 10308  n = 1048576 1', '00 × 100 4', '32 × 100 2', '00 × 101 1', '05 × 106 2', '10 × 107 1', '10 × 1012 1', '15 × 1018 6', '74 × 10315652  \x0csome of these numbers are so large that it is rather diﬃcult to imagine just how long a time span they describe', ' hence the following table gives time spans rather than instruction counts, based on the assumption that we have a computer which can operate at a speed of 1 mip, where one mip = a million instructions per second:  f (n) 1 log2 log2 n log2 n n nlog2 n n2 n3 2n  n = 4 1 µsec 1 µsec 2 µsec 4 µsec 8 µsec 16 µsec 64 µsec 16 µsec  n = 16 1 µsec 2 µsec 4 µsec 16 µsec 64 µsec 256 µsec 4', '1 msec 65', '5 msec  n = 256 1 µsec 3 µsec 8 µsec 256 µsec 2', '05 msec 65', '5 msec 16', '8 sec 3', '7 × 1063 yr  n = 1024 1 µsec 3', '32 µsec 10 µsec 1', '02 msec 1', '02 msec 1', '05 sec 17', '9 min 5', '7 × 10294 yr  n = 1048576 1 µsec 4', '32 µsec 20 µsec 1', '05 sec 21 sec 1', '8 wk 36, 559 yr 2', '1 × 10315639 yr  it is clear that, as the sizes of the problems get really big, there can be huge diﬀerences in the time it takes to run algorithms from diﬀerent complexity classes', ' for algorithms with exponential complexity, o(2n), even modest sized problems have run times that are greater than the age of the universe (about 1', '4 × 1010 yr), and current computers rarely run uninterrupted for more than a few years', ' this is why complexity classes are so important – they tell us how feasible it is likely to be to run a program with a particular large number of data items', ' typically, people do not worry much about complexity for sizes below 10, or maybe 20, but the above numbers make it clear why it is worth thinking about complexity classes where bigger applications are concerned', '  another useful way of thinking about growth classes involves considering how the compute time will vary if the problem size doubles', ' the following table shows what happens for the various complexity classes:  f (n) 1  if the size of the problem doubles then f (n) will be the same,  log2 log2 n almost the same,  log2 n more by 1 = log2 2,  n twice as big as before,  nlog2 n a bit more than twice as big as before, four times as big as before, eight times as big as before, the square of what it was before,  n2 n3 2n  f (2n) = f (n) log2 (log2 (2n)) = log2 (log2 (n) + 1) f (2n) = f (n) + 1 f (2n) = 2f (n) 2nlog2 (2n) = 2(nlog2 n) + 2n f (2n) = 4f (n) f (2n) = 8f (n) f (2n) = (f (n))2  this kind of information can be very useful in practice', ' we can test our program on a problem that is a half or quarter or one eighth of the full size, and have a good idea of how long we will have to wait for the full size problem to ﬁnish', ' moreover, that estimate won’t be aﬀected by any constant factors ignored in computing the growth class, or the speed of the particular computer it is run on', '  the following graph plots some of the complexity class functions from the table', ' note that although these functions are only deﬁned on natural numbers, they are drawn as though they were deﬁned for all real numbers, because that makes it easier to take in the information presented', '  28  \x0cit is clear from these plots why the non-principal growth terms can be safely ignored when computing algorithm complexity', '  5', '5 formal deﬁnition of complexity classes  we have noted that complexity classes are concerned with growth, and the tables and graph above have provided an idea of what diﬀerent behaviours mean when it comes to growth', ' there we have chosen a representative for each of the complexity classes considered, but we have not said anything about just how ‘representative’ such an element is', ' let us now consider a more formal deﬁnition of a ‘big o’ class:  deﬁnition', ' a function g belongs to the complexity class o(f ) if there is a number n0 ∈ n and a constant c > 0 such that for all n ≥ n0, we have that g(n) ≤ c ∗ f (n)', ' we say that the function g is ‘eventually smaller’ than the function c ∗ f ', '  it is not totally obvious what this implies', ' first, we do not need to know exactly when g becomes smaller than c ∗ f ', ' we are only interested in the existence of n0 such that, from then on, g is smaller than c ∗ f ', ' second, we wish to consider the eﬃciency of an algorithm independently of the speed of the computer that is going to execute it', ' this is why f is multiplied by a constant c', ' the idea is that when we measure the time of the steps of a particular algorithm, we are not sure how long each of them takes', ' by deﬁnition, g ∈ o(f ) means that eventually (namely beyond the point n0), the growth of g will be at most as much as the growth of c ∗ f ', ' this deﬁnition also makes it clear that constant factors do not change the growth class (or o-class) of a function', ' hence c(n) = n2 is in the same growth class as c(n) = 1/1000000 ∗ n2 or c(n) = 1000000 ∗ n2', ' so we can write o(n2) = o(1000000 ∗ n2) = o(1/1000000 ∗ n2)', ' typically, however, we choose the simplest representative, as we did in the tables above', ' in this case it is o(n2)', '  29  1020304050607080901000102030405060708090100log n n n log n n2 2n \x0cthe various classes we mentioned above are related as follows:  o(1) ⊆ o(log2 log2 n) ⊆ o(log2 (n)) ⊆ o(n) ⊆ o(nlog2 n) ⊆ o(n2) ⊆ o(n3) ⊆ o(2n)  we only consider the principal growth class, so when adding functions from diﬀerent growth classes, their sum will always be in the larger growth class', ' this allows us to simplify terms', ' for example, the growth class of c(n) = 500000log2 n + 4n2 + 0', '3n + 100 can be determined as follows', ' the summand with the largest growth class is 4n2 (we say that this is the ‘principal sub-term’ or ‘dominating sub-term’ of the function), and we are allowed to drop constant factors, so this function is in the class o(n2)', '  when we say that an algorithm ‘belongs to’ some class o(f ), we mean that it is at most as fast growing as f ', ' we have seen that ‘linear searching’ (where one searches in a collection of data items which is unsorted) has linear complexity, i', 'e', ' it is in growth class o(n)', ' this holds for the average case as well as the worst case', ' the operations needed are comparisons of the item we are searching for with all the items appearing in the data collection', ' in the worst case, we have to check all n entries until we ﬁnd the right one, which means we make n comparisons', ' on average, however, we will only have to check n/2 entries until we hit the correct one, leaving us with n/2 operations', ' both those functions, c(n) = n and c(n) = n/2 belong to the same complexity class, namely o(n)', ' however, it would be equally correct to say that the algorithm belongs to o(n2), since that class contains all of o(n)', ' but this would be less informative, and we would not say that an algorithm has quadratic complexity if we know that, in fact, it is linear', ' sometimes it is diﬃcult to be sure what the exact complexity is (as is the case with the famous np = p problem), in which case one might say that an algorithm is ‘at most’, say, quadratic', '  the issue of eﬃciency and complexity class, and their computation, will be a recurring feature throughout the chapters to come', ' we shall see that concentrating only on the com- plexity class, rather than ﬁnding exact complexity functions, can render the whole process of considering eﬃciency much easier', ' in most cases, we can determine the time complexity by a simple counting of the loops and tree heights', ' however, we will also see at least one case where that results in an overestimate, and a more exact computation is required', '  30  \x0cchapter 6  trees  in computer science, a tree is a very general and powerful data structure that resembles a real tree', ' it consists of an ordered set of linked nodes in a connected graph, in which each node has at most one parent node, and zero or more children nodes with a speciﬁc order', '  6', '1 general speciﬁcation of trees  generally, we can specify a tree as consisting of nodes (also called vertices or points) and edges (also called lines, or, in order to stress the directedness, arcs) with a tree-like structure', ' it is usually easiest to represent trees pictorially, so we shall frequently do that', ' a simple example is given in figure 6', '1:  figure 6', '1: example of a tree', '  more formally, a tree can be deﬁned as either the empty tree, or a node with a list of successor trees', ' nodes are usually, though not always, labelled with a data item (such as a number or search key)', ' we will refer to the label of a node as its value', ' in our examples, we will generally use nodes labelled by integers, but one could just as easily choose something else, e', 'g', ' strings of characters', '  in order to talk rigorously about trees, it is convenient to have some terminology: there always has to be a unique ‘top level’ node known as the root', ' in figure 6', '1, this is the node labelled with 8', ' it is important to note that, in computer science, trees are normally displayed upside-down, with the root forming the top level', ' then, given a node, every node on the next level ‘down’, that is connected to the given node via a branch, is a child of that node', ' in  31  1083171191412156\x0cfigure 6', '1, the children of node 8 are nodes 3 and 11', ' conversely, the node (there is at most one) connected to the given node (via an edge) on the level above, is its parent', ' for instance, node 11 is the parent of node 9 (and of node 14 as well)', ' nodes that have the same parent are known as siblings – siblings are, by deﬁnition, always on the same level', '  if a node is the child of a child of ', ' ', ' ', ' of a another node then we say that the ﬁrst node is a descendent of the second node', ' conversely, the second node is an ancestor of the ﬁrst node', ' nodes which do not have any children are known as leaves (e', 'g', ', the nodes labelled with 1, 7, 10, 12, and 15 in figure 6', '1)', '  a path is a sequence of connected edges from one node to another', ' trees have the property that for every node there is a unique path connecting it with the root', ' in fact, that is another possible deﬁnition of a tree', ' the depth or level of a node is given by the length of this path', ' hence the root has level 0, its children have level 1, and so on', ' the maximal length of a path in a tree is also called the height of the tree', ' a path of maximal length always goes from the root to a leaf', ' the size of a tree is given by the number of nodes it contains', ' we shall normally assume that every tree is ﬁnite, though generally that need not be the case', ' the tree in figure 6', '1 has height 3 and size 11', ' a tree consisting of just of one node has height 0 and size 1', ' the empty tree obviously has size 0 and is deﬁned (conveniently, though somewhat artiﬁcially) to have height −1', '  like most data structures, we need a set of primitive operators (constructors, selectors and conditions) to build and manipulate the trees', ' the details of those depend on the type and purpose of the tree', ' we will now look at some particularly useful types of tree', '  6', '2 quad-trees  a quadtree is a particular type of tree in which each leaf-node is labelled by a value and each non-leaf node has exactly four children', ' it is used most often to partition a two dimensional space (e', 'g', ', a pixelated image) by recursively dividing it into four quadrants', '  formally, a quadtree can be deﬁned to be either a single node with a number or value (e', 'g', ', in the range 0 to 255), or a node without a value but with four quadtree children: lu, ll, ru, and rl', ' it can thus be deﬁned “inductively” by the following rules:  deﬁnition', ' a quad tree is either  (rule 1) a root node with a value, or  (rule 2) a root node without a value and four quad tree children: lu, ll, ru, and rl', '  in which rule 1 is the “base case” and rule 2 is the “induction step”', '  we say that a quadtree is primitive if it consists of a single node/number, and that can  be tested by the corresponding condition:  • isvalue(qt), which returns true if quad-tree qt is a single node', '  to build a quad-tree we have two constructors:  • baseqt(value), which returns a single node quad-tree with label value', '  • makeqt(luqt, ruqt, llqt, rlqt), which builds a quad-tree from four constituent quad-  trees luqt, llqt, ruqt, rlqt', '  32  \x0cthen to extract components from a quad-tree we have four selectors:  • lu(qt), which returns the left-upper quad-tree', '  • ru(qt), which returns the right-upper quad-tree', '  • ll(qt), which returns the left-lower quad-tree', '  • rl(qt), which returns the right-lower quad-tree', '  which can be applied whenever isvalue(qt) is false', ' for cases when isvalue(qt) is true, we could deﬁne an operator value(qt) that returns the value, but conventionally we simply say that qt itself is the required value', '  quad-trees of this type are most commonly used to store grey-value pictures (with 0  representing black and 255 white)', ' a simple example would be:  we can then create algorithms using the operators to perform useful manipulations of the representation', ' for example, we could rotate a picture qt by 180◦ using:  rotate(qt) {  if ( isvalue(qt) )  return qt  else return makeqt( rotate(rl(qt)), rotate(ll(qt)),  rotate(ru(qt)), rotate(lu(qt)) )  }  or we could compute average values by recursively averaging the constituent sub-trees', '  there exist numerous variations of this general idea, such coloured quadtrees which store value-triples that represent colours rather than grey-scale, and edge quad-trees which store lines and allow curves to be represented with arbitrary precision', '  6', '3 binary trees  binary trees are the most common type of tree used in computer science', ' a binary tree is a tree in which every node has at most two children, and can be deﬁned “inductively” by the following rules:  33  1020304050607080110100120900\x0cdeﬁnition', ' a binary tree is either  (rule 1) the empty tree emptytree, or  (rule 2) it consists of a node and two binary trees, the left subtree and right subtree', '  again, rule 1 is the “base case” and rule 2 is the “induction step”', ' this deﬁnition may appear circular, but actually it is not, because the subtrees are always simpler than the original one, and we eventually end up with an empty tree', '  you can imagine that the (inﬁnite) collection of (ﬁnite) trees is created in a sequence of days', ' day 0 is when you “get oﬀ the ground” by applying rule 1 to get the empty tree', ' on later days, you are allowed to use any trees that you have created on earlier days to construct new trees using rule 2', ' thus, for example, on day 1 you can create exactly trees that have a root with a value, but no children (i', 'e', ' both the left and right subtrees are the empty tree, created at day 0)', ' on day 2 you can use a new node with value, with the empty tree and/or the one-node tree, to create more trees', ' thus, binary trees are the objects created by the above two rules in a ﬁnite number of steps', ' the height of a tree, deﬁned above, is the number of days it takes to create it using the above two rules, where we assume that only one rule is used per day, as we have just discussed', ' (exercise: work out the sequence of steps needed to create the tree in figure 6', '1 and hence prove that it is in fact a binary tree', ')  6', '4 primitive operations on binary trees  the primitive operators for binary trees are fairly obvious', ' we have two constructors which are used to build trees:  • maketree(v, l, r), which builds a binary tree from a root node with label v and two  • emptytree, which returns an empty tree,  constituent binary trees l and r,  a condition to test whether a tree is empty:  • isempty(t), which returns true if tree t is the emptytree,  and three selectors to break a non-empty tree into its constituent parts:  • root(t), which returns the value of the root node of binary tree t,  • left(t), which returns the left sub-tree of binary tree t,  • right(t), which returns the right sub-tree of binary tree t', '  these operators can be used to create all the algorithms we might need for manipulating binary trees', '  for convenience though, it is often a good idea to deﬁne derived operators that allow us to  write simpler, more readable algorithms', ' for example, we can deﬁne a derived constructor:  • leaf(v) = maketree(v, emptytree, emptytree)  that creates a tree consisting of a single node with label v, which is the root and the unique leaf of the tree at the same time', ' then the tree in figure 6', '1 can be constructed as:  34  \x0ct = maketree(8, maketree(3,leaf(1),maketree(6,emptytree,leaf(7))),  maketree(11,maketree(9,emptytree,leaf(10)),maketree(14,leaf(12),leaf(15))))  which is much simpler than the construction using the primitive operators:  t = maketree(8, maketree(3,maketree(1,emptytree,emptytree), maketree(6,emptytree,maketree(7,emptytree,emptytree))),  maketree(11,maketree(9,emptytree,maketree(10,emptytree,emptytree)),  maketree(14,maketree(12,emptytree,emptytree),  maketree(15,emptytree,emptytree))))  note that the selectors can only operate on non-empty trees', ' for example, for the tree t  deﬁned above we have  root(left(left(t)) = 1,  but the expression  root(left(left(left(t))))  does not make sense because  left(left(left(t))) = emptytree  and the empty tree does not have a root', ' in a language such as java, this would typically raise an exception', ' in a language such as c , this would cause an unpredictable behaviour, but if you are lucky, a core dump will be produced and the program will be aborted with no further harm', ' when writing algorithms, we need to check the selector arguments using isempty(t) before allowing their use', '  the following equations should be obvious from the primitive operator deﬁnitions:  root(maketree(v,l,r)) = v left(maketree(v,l,r)) = l right(maketree(v,l,r)) = r isempty(emptytree) = true isempty(maketree(v,l,r)) = false  the following makes sense only under the assumption that t is a non-empty tree:  maketree(root(t),left(t),right(t)) = t  it just says that if we break apart a non-empty tree and use the pieces to build a new tree, then we get an identical tree back', '  it is worth emphasizing that the above speciﬁcations of quad-trees and binary trees are further examples of abstract data types: data types for which we exhibit the constructors and destructors and describe their behaviour (using equations such as deﬁned above for lists, stacks, queues, quad-trees and binary trees), but for which we explicitly hide the implemen- tational details', ' the concrete data type used in an implementation is called a data structure', ' for example, the usual data structures used to implement the list and tree data types are records and pointers – but other implementations are possible', '  the important advantage of abstract data types is that we can develop algorithms without having to worry about the details of the representation of the data or the implementation', ' of course, everything will ultimately be represented as sequences of bits in a computer, but we clearly do not generally want to have to think in such low level terms', '  35  \x0c6', '5 the height of a binary tree  binary trees don’t have a simple relation between their size n and height h', ' the maximum height of a binary tree with n nodes is (n − 1), which happens when all non-leaf nodes have precisely one child, forming something that looks like a chain', ' on the other hand, suppose we have n nodes and want to build from them a binary tree with minimal height', ' we can achieve this by ‘ﬁlling’ each successive level in turn, starting from the root', ' it does not matter where we place the nodes on the last (bottom) level of the tree, as long as we don’t start adding to the next level before the previous level is full', ' terminology varies, but we shall say that such trees are perfectly balanced or height balanced , and we shall see later why they are optimal for many of our purposes', ' basically, if done appropriately, many important tree-based operations (such as searching) take as many steps as the height of the tree, so minimizing the height minimizes the time needed to perform those operations', '  we can easily determine the maximum number of nodes that can ﬁt into a binary tree of  a given height h', ' calling this size function s(h), we obtain:  h 0 1 2 3  s(h) 1 3 7 15  in fact, it seems fairly obvious that s(h) = 1 + 2 + 4 + · · · + 2h = 2h+1 − 1', ' this hypothesis can be proved by induction using the deﬁnition of a binary tree as follows:  (a) the base case applies to the empty tree that has height h = −1, which is consistent  with s(−1) = 2−1+1 − 1 = 20 − 1 = 1 − 1 = 0 nodes being stored', '  (b) then for the induction step, a tree of height h + 1 has a root node plus two subtrees of height h', ' by the induction hypothesis, each subtree can store s(h) = 2h+1 − 1 nodes, so the total number of nodes that can ﬁt in a height h + 1 tree is 1 + 2 × (2h+1 − 1) = 1 + 2h+2 − 2 = 2(h+1)+1 − 1 = s(h + 1)', ' it follows that if s(h) is correct for the empty tree, which it was shown to be in the base case above, then it is correct for all h', '  an obvious potential problem with any proof by induction like this, however, is the need to identify an induction hypothesis to start with, and that is not always easy', '  another way to proceed here would be to simply sum the series s(h) = 1 + 2 + 4 + · · · + 2h algebraically to get the answer', ' sometimes, however, the relevant series is too complicated to sum easily', ' an alternative is to try to identify two diﬀerent expressions for s(h + 1) as a function of s(h), and solve them for s(h)', ' here, since level h of a tree clearly has 2h nodes, we can explicitly add in the 2h+1 nodes of the last level of the height h + 1 tree to give  also, since a height h + 1 tree is made up of a root node plus two trees of height h  then subtracting the second equation from the ﬁrst gives  s(h + 1) = s(h) + 2h+1  s(h + 1) = 1 + 2s(h)  s(h) = 2h+1 − 1  36  \x0cwhich is the required answer', ' from this we can get an expression for h  h = log2 (s + 1) − 1 ≈ log2 s  in which the approximation is valid for large s', '  hence a perfectly balanced tree consisting of n nodes has height approximately log2 n', '  this is good, because log2 n is very small, even for relatively large n:  n log2 n 1 2 5 32 10 1, 024 20 1, 048, 576  we shall see later how we can use binary trees to hold data in such a way that any search has at most as many steps as the height of the tree', ' therefore, for perfectly balanced trees we can reduce the search time considerably as the table demonstrates', ' however, it is not always easy to create perfectly balanced trees, as we shall also see later', '  6', '6 the size of a binary tree  usually a binary tree will not be perfectly balanced, so we will need an algorithm to determine its size, i', 'e', ' the number of nodes it contains', '  this is easy if we use recursion', ' the terminating case is very simple: the empty tree has size 0', ' otherwise, any binary tree will always be assembled from a root node, a left sub-tree l, and a right sub-tree r, and its size will be the sum of the sizes of its components, i', 'e', ' 1 for the root, plus the size of l, plus the size of r', ' we have already deﬁned the primitive operator isempty(t) to check whether a binary tree t is empty, and the selectors left(t) and right(t) which return the left and right sub-trees of binary tree t', ' thus we can easily deﬁne the procedure size(t), which takes a binary tree t and returns its size, as follows:  size(t) {  if ( isempty(t) )  return 0  }  else return (1 + size(left(t)) + size(right(t)))  this recursively processes the whole tree, and we know it will terminate because the trees being processed get smaller with each call, and will eventually reach an empty tree which returns a simple value', '  6', '7  implementation of trees  the natural way to implement trees is in terms of records and pointers, in a similar way to how linked lists were represented as two-cells consisting of a pointer to a list element and a pointer to the next two-cell', ' obviously, the details will depend on how many children each node can have, but trees can generally be represented as data structures consisting of a pointer to the root-node content (if any) and pointers to the children sub-trees', ' the inductive deﬁnition  37  \x0cof trees then allows recursive algorithms on trees to operate eﬃciently by simply passing the pointer to the relevant root-node, rather than having to pass complete copies of whole trees', ' how data structures and pointers are implemented in diﬀerent programming languages will vary, of course, but the general idea is the same', '  a binary tree can be implemented as a data record for each node consisting simply of the node value and two pointers to the children nodes', ' then maketree simply creates a new data record of that form, and root, left and right simply read out the relevant contents of the record', ' the absence of a child node can be simply represented by a null pointer', '  6', '8 recursive algorithms  some people have diﬃculties with recursion', ' a source of confusion is that it appears that “the algorithm calls itself” and it might therefore get confused about what it is operating on', ' this way of putting things, although suggestive, can be misleading', ' the algorithm itself is a passive entity, which actually cannot do anything at all, let alone call itself', ' what happens is that a processor (which can be a machine or a person) executes the algorithm', ' so what goes on when a processor executes a recursive algorithm such as the size(t) algorithm above? an easy way of understanding this is to imagine that whenever a recursive call is encountered, new processors are given the task with a copy of the same algorithm', '  for example, suppose that john (the ﬁrst processor in this task) wants to compute the size of a given tree t using the above recursive algorithm', ' then, according to the above algorithm, john ﬁrst checks whether it is empty', ' if it is, he simply returns zero and ﬁnishes his computation', ' if it isn’t empty, then his tree t must have left and right subtrees l and r (which may, or may not, be empty) and he can extract them using the selectors left(t) and right(t)', ' he can then ask two of his students, say steve and mary, to execute the same algorithm, but for the trees l and r', ' when they ﬁnish, say returning results m and n respectively, he computes and returns 1+m+n, because his tree has a root node in addition to the left and right sub-trees', ' if steve and mary aren’t given empty trees, they will themselves have to delegate executions of the same algorithm, with their sub-trees, to other people', ' thus, the algorithm is not calling itself', ' what happens, is that there are many people running their own copies of the same algorithm on diﬀerent trees', '  in this example, in order to make things understandable, we assumed that each person executes a single copy of the algorithm', ' however, the same processor, with some diﬃculty, can impersonate several processors, in such a way that it achieves the same result as the execution involving many processors', ' this is achieved via the use of a stack that keeps track of the various positions of the same algorithm that are currently being executed – but this knowledge is not needed for our purposes', '  note that there is nothing to stop us keeping count of the recursions by passing integers  along with any data structures being operated on, for example:  function(int n, tree t) {  // terminating condition and return  // procedure details  ', '  ', '  return function(n-1, t2)  }  38  \x0cso we can do something n times, or look for the nth item, etc', ' the classic example is the recursive factorial function:  another example, with two termination or base-case conditions, is a direct implementation of the recursive deﬁnition of fibonacci numbers (see appendix a', '5):  factorial(int n) {  if ( n == 0 ) return 1 return n*factorial(n-1)  f(int n) {  if ( n == 0 ) return 0 if ( n == 1 ) return 1 return f(n-1) + f(n-2)  }  }  though this is an extremely ineﬃcient algorithm for computing these numbers', ' exercise: show that the time complexity of this algorithm is o(2n), and that there exists a straightforward is it possible to create an o(n) iterative algorithm that has only o(n) time complexity', ' recursive algorithm to compute these numbers?  in most cases, however, we won’t need to worry about counters, because the relevant data structure has a natural end point condition, such as isempty(x), that will bring the recursion to an end', '  39  \x0cchapter 7  binary search trees  we now look at binary search trees, which are a particular type of binary tree that provide an eﬃcient way of storing data that allows particular items to be found as quickly as possible', ' then we consider further elaborations of these trees, namely avl trees and b-trees, which operate more eﬃciently at the expense of requiring more sophisticated algorithms', '  7', '1 searching with arrays or lists  as we have already seen in chapter 4, many computer science applications involve searching for a particular item in a collection of data', ' if the data is stored as an unsorted array or list, then to ﬁnd the item in question, one obviously has to check each entry in turn until the correct one is found, or the collection is exhausted', ' on average, if there are n items, this will take n/2 checks, and in the worst case, all n items will have to be checked', ' if the collection is large, such as all items accessible via the internet, that will take too much time', ' we also saw that if the items are sorted before storing in an array, one can perform binary search which only requires log2 n checks in the average and worst cases', ' however, that involves an overhead of sorting the array in the ﬁrst place, or maintaining a sorted array if items are inserted or deleted over time', ' the idea here is that, with the help of binary trees, we can speed up the storing and search process without needing to maintain a sorted array', '  7', '2 search keys  if the items to be searched are labelled by comparable keys, one can order them and store them in such a way that they are sorted already', ' being ‘sorted’ may mean diﬀerent things for diﬀerent keys, and which key to choose is an important design decision', '  in our examples, the search keys will, for simplicity, usually be integer numbers (such as student id numbers), but other choices occur in practice', ' for example, the comparable keys could be words', ' in that case, comparability usually refers to the alphabetical order', ' if w and t are words, we write w < t to mean that w precedes t in the alphabetical order', ' if w = bed and t = sky then the relation w < t holds, but this is not the case if w = bed and t = abacus', ' a classic example of a collection to be searched is a dictionary', ' each entry of the dictionary is a pair consisting of a word and a deﬁnition', ' the deﬁnition is a sequence of words and punctuation symbols', ' the search key, in this example, is the word (to which a deﬁnition is attached in the dictionary entry)', ' thus, abstractly, a dictionary is a sequence of  40  \x0centries, where an entry is a pair consisting of a word and its deﬁnition', ' this is what matters from the point of view of the search algorithms we are going to consider', ' in what follows, we shall concentrate on the search keys, but should always bear in mind that there is usually a more substantial data entry associated with it', '  notice the use of the word “abstract” here', ' what we mean is that we abstract or remove any details that are irrelevant from the point of view of the algorithms', ' for example, a dictionary usually comes in the form of a book, which is a sequence of pages – but for us, the distribution of dictionary entries into pages is an accidental feature of the dictionary', ' all that matters for us is that the dictionary is a sequence of entries', ' so “abstraction” means “getting rid of irrelevant details”', ' for our purposes, only the search key is important, so we will ignore the fact that the entries of the collection will typically be more complex objects (as in the example of a dictionary or a phone book)', '  note that we should always employ the data structure to hold the items which performs best for the typical application', ' there is no easy answer as to what the best choice is – the particular circumstances have to be inspected, and a decision has to be made based on that', ' however, for many applications, the kind of binary trees we studied in the last chapter are particularly useful here', '  7', '3 binary search trees  the solution to our search problem is to store the collection of data to be searched using a binary tree in such a way that searching for a particular item takes minimal eﬀort', ' the underlying idea is simple: at each tree node, we want the value of that node to either tell us that we have found the required item, or tell us which of its two subtrees we should search for it in', ' for the moment, we shall assume that all the items in the data collection are distinct, with diﬀerent search keys, so each possible node value occurs at most once, but we shall see later that it is easy to relax this assumption', ' hence we deﬁne:  deﬁnition', ' a binary search tree is a binary tree that is either empty or satisﬁes the following conditions:  • all values occurring in the left subtree are smaller than that of the root', '  • all values occurring in the right subtree are larger than that of the root', '  • the left and right subtrees are themselves binary search trees', '  so this is just a particular type of binary tree, with node values that are the search keys', ' this means we can inherit many of the operators and algorithms we deﬁned for general binary trees', ' in particular, the primitive operators maketree(v, l, r), root(t), left(t), right(t) and isempty(t) are the same – we just have to maintain the additional node value ordering', '  7', '4 building binary search trees  when building a binary search tree, one naturally starts with the root and then adds further new nodes as needed', ' so, to insert a new value v, the following cases arise:  • if the given tree is empty, then simply assign the new value v to the root, and leave the  left and right subtrees empty', '  41  \x0c• if the given tree is non-empty, then insert a node with value v as follows:  – if v is smaller than the value of the root: insert v into the left sub-tree', '  – if v is larger than the value of the root: insert v into the right sub-tree', '  – if v is equal to the value of the root: report a violated assumption', '  thus, using the primitive binary tree operators, we have the procedure:  insert(v,bst) {  if ( isempty(bst) )  return maketree(v, emptytree, emptytree)  elseif ( v < root(bst) )  return maketree(root(bst), insert(v,left(bst)), right(bst))  elseif ( v > root(bst) )  return maketree(root(bst), left(bst), insert(v,right(bst)))  else error(‘error: violated assumption in procedure insert', '’)  }  which inserts a node with value v into an existing binary search tree bst', ' note that the node added is always a leaf', ' the resulting tree is once again a binary search tree', ' this can be proved rigorously via an inductive argument', '  note that this procedure creates a new tree out of a given tree bst and new value v, with the new value inserted at the right position', ' the original tree bst is not modiﬁed, it is merely inspected', ' however, when the tree represents a large database, it would clearly be more eﬃcient to modify the given tree, rather than to construct a whole new tree', ' that can easily be done by using pointers, similar to the way we set up linked lists', ' for the moment, though, we shall not concern ourselves with such implementational details', '  7', '5 searching a binary search tree  searching a binary search tree is not dissimilar to the process performed when inserting a new item', ' we simply have to compare the item being looked for with the root, and then keep ‘pushing’ the comparison down into the left or right subtree depending on the result of each root comparison, until a match is found or a leaf is reached', '  algorithms can be expressed in many ways', ' here is a concise description in words of the  search algorithm that we have just outlined:  in order to search for a value v in a binary search tree t, proceed as follows', ' if t is empty, then v does not occur in t, and hence we stop with false', ' otherwise, if v is equal to the root of t, then v does occur in t, and hence we stop returning true', ' if, on the other hand, v is smaller than the root, then, by deﬁnition of a binary search tree, it is enough to search the left sub-tree of t', ' hence replace t by its left sub-tree and carry on in the same way', ' similarly, if v is bigger than the root, replace t by its right sub-tree and carry on in the same way', '  notice that such a description of an algorithm embodies both the steps that need to be carried out and the reason why this gives a correct solution to the problem', ' this way of describing algorithms is very common when we do not intend to run them on a computer', '  42  \x0cwhen we do want to run them, we need to provide a more precise speciﬁcation, and would  normally write the algorithm in pseudocode, such as the following recursive procedure:  isin(value v, tree t) { if ( isempty(t) ) return false  elseif ( v == root(t) )  return true  elseif ( v < root(t) )  return isin(v, left(t))  else  return isin(v, right(t))  }  }  each recursion restricts the search to either the left or right subtree as appropriate, reducing the search tree height by one, so the algorithm is guaranteed to terminate eventually', '  in this case, the recursion can easily be transformed into a while-loop:  isin(value v, tree t) {  while ( (not isempty(t)) and (v != root(t)) )  if (v < root(t) ) t = left(t)  else  t = right(t) return ( not isempty(t) )  here, each iteration of the while-loop restricts the search to either the left or right subtree as appropriate', ' the only way to leave the loop is to have found the required value, or to only have an empty tree remaining, so the procedure only needs to return whether or not the ﬁnal tree is empty', '  in practice, we often want to have more than a simple true/false returned', ' for example, if we are searching for a student id, we usually want a pointer to the full record for that student, not just a conﬁrmation that they exist', ' in that case, we could store a record pointer associated with the search key (id) at each tree node, and return the record pointer or a null pointer, rather than a simple true or false, when an item is found or not found', ' clearly, the basic tree structures we have been discussing can be elaborated in many diﬀerent ways like this to form whatever data-structure is most appropriate for the problem at hand, but, as noted above, we can abstract out such details for current purposes', '  7', '6 time complexity of insertion and search  as always, it is important to understand the time complexity of our algorithms', ' both item insertion and search in a binary search tree will take at most as many comparisons as the height of the tree plus one', ' at worst, this will be the number of nodes in the tree', ' but how many comparisons are required on average? to answer this question, we need to know the average height of a binary search tree', ' this can be calculated by taking all possible binary search trees of a given size n and measuring each of their heights, which is by no means an  43  \x0ceasy task', ' the trouble is that there are many ways of building the same binary search tree by successive insertions', '  as we have seen above, perfectly balanced trees achieve minimal height for a given number of nodes, and it turns out that the more balanced a tree, the more ways there are of building it', ' this is demonstrated in the ﬁgure below:  the only way of getting the tree on the left hand side is by inserting 3, 2, 1 into the empty tree in that order', ' the tree on the right, however, can be reached in two ways: inserting in the order 2, 1, 3 or in the order 2, 3, 1', ' ideally, of course, one would only use well-balanced trees to keep the height minimal, but they do not have to be perfectly balanced to perform better than binary search trees without restrictions', '  carrying out exact tree height calculations is not straightforward, so we will not do that here', ' however, if we assume that all the possible orders in which a set of n nodes might be inserted into a binary search tree are equally likely, then the average height of a binary search tree turns out to be o(log2 n)', ' it follows that the average number of comparisons needed to search a binary search tree is o(log2 n), which is the same complexity we found for binary search of a sorted array', ' however, inserting a new node into a binary search tree also depends on the tree height and requires o(log2 n) steps, which is better than the o(n) complexity of inserting an item into the appropriate point of a sorted array', '  interestingly, the average height of a binary search tree is quite a bit better than the average height of a general binary tree consisting of the same n nodes that have not been built into a binary search tree', ' the average height of a general binary tree is actually o( n)', ' the reason for that is that there is a relatively large proportion of high binary trees that are not valid binary search trees', '  √  7', '7 deleting nodes from a binary search tree  suppose, for some reason, an item needs to be removed or deleted from a binary search tree', ' it would obviously be rather ineﬃcient if we had to rebuild the remaining search tree again from scratch', ' for n items that would require n steps of o(log2 n) complexity, and hence have overall time complexity of o(nlog2 n)', ' by comparison, deleting an item from a sorted array would only have time complexity o(n), and we certainly want to do better than that', ' instead, we need an algorithm that produces an updated binary search tree more eﬃciently', ' this is more complicated than one might assume at ﬁrst sight, but it turns out that the following algorithm works as desired:  • if the node in question is a leaf, just remove it', '  • if only one of the node’s subtrees is non-empty, ‘move up’ the remaining subtree', '  • if the node has two non-empty sub-trees, ﬁnd the ‘left-most’ node occurring in the right sub-tree (this is the smallest item in the right subtree)', ' use this node to overwrite the  44  312213\x0cone that is to be deleted', ' replace the left-most node by its right subtree, if this exists; otherwise just delete it', '  the last part works because the left-most node in the right sub-tree is guaranteed to be bigger than all nodes in the left sub-tree, smaller than all the other nodes in the right sub-tree, and have no left sub-tree itself', ' for instance, if we delete the node with value 11 from the tree in figure 6', '1, we get the tree displayed in figure 7', '1', '  figure 7', '1: example of node deletion in a binary search tree', '  in practice, we need to turn the above algorithm (speciﬁed in words) into a more detailed algorithm speciﬁed using the primitive binary tree operators:  delete(value v, tree t) {  if ( isempty(t) )  else  error(‘error: given item is not in given tree’)  if ( v < root(t) )  // delete from left sub-tree  else if ( v > root(t) )  return maketree(root(t), delete(v,left(t)), right(t)); // delete from right sub-tree return maketree(root(t), left(t), delete(v,right(t)));  else  // the item v to be deleted is root(t)  if ( isempty(left(t)) )  return right(t)  elseif ( isempty(right(t)) )  return left(t)  else  // difficult case with both subtrees non-empty  return maketree(smallestnode(right(t)), left(t),  removesmallestnode(right(t))  }  if the empty tree condition is met, it means the search item is not in the tree, and an appropriate error message should be returned', '  the delete procedure uses two sub-algorithms to ﬁnd and remove the smallest item of a given sub-tree', ' since the relevant sub-trees will always be non-empty, these sub-algorithms can be written with that precondition', ' however, it is always the responsibility of the programmer to ensure that any preconditions are met whenever a given procedure is used, so it is important to say explicitly what the preconditions are', ' it is often safest to start each procedure with a  45  108317119141215610831791415612\x0ccheck to determine whether the preconditions are satisﬁed, with an appropriate error message produced when they are not, but that may have a signiﬁcant time cost if the procedure is called many times', ' first, to ﬁnd the smallest node, we have:  smallestnode(tree t) {  // precondition: t is a non-empty binary search tree if ( isempty(left(t) )  return root(t)  else  return smallestnode(left(t));  which uses the fact that, by the deﬁnition of a binary search tree, the smallest node of t is the left-most node', ' it recursively looks in the left sub-tree till it reaches an empty tree, at which point it can return the root', ' the second sub-algorithm uses the same idea:  removesmallestnode(tree t) {  // precondition: t is a non-empty binary search tree if ( isempty(left(t) ) return right(t)  else  return maketree(root(t), removesmallestnode(left(t)), right(t))  except that the remaining tree is returned rather than the smallest node', '  these procedures are further examples of recursive algorithms', ' in each case, the recursion is guaranteed to terminate, because every recursive call involves a smaller tree, which means that we will eventually ﬁnd what we are looking for or reach an empty tree', '  it is clear from the algorithm that the deletion of a node requires the same number of steps as searching for a node, or inserting a new node, i', 'e', ' the average height of the binary search tree, or o(log2 n) where n is the total number of nodes on the tree', '  7', '8 checking whether a binary tree is a binary search tree  building and using binary search trees as discussed above is usually enough', ' however, another thing we sometimes need to do is check whether or not a given binary tree is a binary search tree, so we need an algorithm to do that', ' we know that an empty tree is a (trivial) binary search tree, and also that all nodes in the left sub-tree must be smaller than the root and themselves form a binary search tree, and all nodes in the right sub-tree must be greater than the root and themselves form a binary search tree', ' thus the obvious algorithm is:  isbst(tree t) {  if ( isempty(t) ) return true  else  return ( allsmaller(left(t),root(t)) and isbst(left(t))  and allbigger(right(t),root(t)) and isbst(right(t)) )  }  }  }  46  \x0creturn ( (root(t) < v) and allsmaller(left(t),v)  and allsmaller(right(t),v) )  return ( (root(t) > v) and allbigger(left(t),v)  and allbigger(right(t),v) )  however, the simplest or most obvious algorithm is not always the most eﬃcient', ' exercise: identify what is ineﬃcient about this algorithm, and formulate a more eﬃcient algorithm', '  7', '9 sorting using binary search trees  sorting is the process of putting a collection of items in order', ' we shall formulate and discuss many sorting algorithms later, but we are already able to present one of them', '  the node values stored in a binary search tree can be printed in ascending order by  recursively printing each left sub-tree, root, and right sub-tree in the right order as follows:  allsmaller(tree t, value v) {  if ( isempty(t) ) return true  else  allbigger(tree t, value v) {  if ( isempty(t) ) return true  else  }  }  printinorder(tree t) {  if ( not isempty(t) ) {  printinorder(left(t)) print(root(t)) printinorder(right(t))  }  }  sort(array a of size n) {  t = emptytree for i = 0,1,', '', '', ',n-1  t = insert(a[i],t)  printinorder(t)  }  then, if the collection of items to be sorted is given as an array a of known size n, they can be printed in sorted order by the algorithm:  which starts with an empty tree, inserts all the items into it using insert(v, t) to give a binary search tree, and then prints them in order using printinorder(t)', ' exercise: modify this algorithm so that instead of printing the sorted values, they are put back into the original array in ascending order', '  47  \x0c7', '10 balancing binary search trees  if the items are added to a binary search tree in random order, the tree tends to be fairly well balanced with height not much more than log2 n', ' however, there are many situations where the added items are not in random order, such as when adding new student ids', ' in the extreme case of the new items being added in ascending order, the tree will be one long branch oﬀ to the right, with height n (cid:29) log2 n', '  if all the items to be inserted into a binary search tree are already sorted, it is straight- forward to build a perfectly balanced binary tree from them', ' one simply has to recursively build a binary tree with the middle (i', 'e', ', median) item as the root, the left subtree made up of the smaller items, and the right subtree made up of the larger items', ' this idea can be used to rebalance any existing binary search tree, because the existing tree can easily be output into a sorted array as discussed in section 7', '9', ' exercise: write an algorithm that rebalances a binary search tree in this way, and work out its time complexity', '  another way to avoid unbalanced binary search trees is to rebalance them from time to time using tree rotations', ' such tree rotations are best understood as follows: any binary search tree containing at least two nodes can clearly be drawn in one of the two forms:  where b and d are the required two nodes to be rotated, and a, c and e are binary search sub-trees (any of which may be empty)', ' the two forms are related by left and right tree rotations which clearly preserve the binary search tree property', ' in this case, any nodes in sub-tree a would be shifted up the tree by a right rotation, and any nodes in sub-tree e would be shifted up the tree by a left rotation', ' for example, if the left form had a consisting of two nodes, and c and e consisting of one node, the height of the tree would be reduced by one and become perfectly balanced by a right tree rotation', '  typically, such tree rotations would need to be applied to many diﬀerent sub-trees of a full tree to make it perfectly balanced', ' for example, if the left form had c consisting of two nodes, and a and e consisting of one node, the tree would be balanced by ﬁrst performing in a left rotation of the a-b-c sub-tree, followed by a right rotation of the whole tree', ' practice, ﬁnding suitable sequences of appropriate tree rotations to rebalance an arbitrary binary search tree is not straightforward, but it is possible to formulate systematic balancing algorithms that are more eﬃcient than outputting the whole tree and rebuilding it', '  7', '11 self-balancing avl trees  self-balancing binary search trees avoid the problem of unbalanced trees by automatically rebalancing the tree throughout the insertion process to keep the height close to log2 n at each stage', ' obviously, there will be a cost involved in such rebalancing, and there will be a  48  \x0ctrade-oﬀ between the time involved in rebalancing and the time saved by the reduced height of the tree, but generally it is worthwhile', '  the earliest type of self-balancing binary search tree was the avl tree (named after its inventors g', 'm', ' adelson-velskii and e', 'm', ' landis)', ' these maintain the diﬀerence in heights of the two sub-trees of all nodes to be at most one', ' this requires the tree to be periodically rebalanced by performing one or more tree rotations as discussed above, but the complexity of insertion, deletion and search remain at o(log2 n)', '  the general idea is to keep track of the balance factor for each node, which is the height of the left sub-tree minus the height of the right sub-tree', ' by deﬁnition, all the nodes in an avl-tree will have a balance factor in the integer range [−1, 1]', ' however, insertion or deletion of a node could leave that in the wider range [−2, 2] requiring a tree-rotation to bring it back into avl form', ' exercise: find some suitable algorithms for performing eﬃcient avl tree rotations', ' compare them with other self-balancing approaches such as red-black trees', '  7', '12 b-trees  a b-tree is a generalization of a self-balancing binary search tree in which each node can hold more than one search key and have more than two children', ' the structure is designed to allow more eﬃcient self-balancing, and oﬀers particular advantages when the node data needs to be kept in external storage such as disk drives', ' the standard (knuth) deﬁnition is:  deﬁnition', ' a b-tree of order m is a tree which satisﬁes the following conditions:  • every node has at most m children', '  • every non-leaf node (except the root node) has at least m/2 children', '  • the root node, if it is not a leaf node, has at least two children', '  • a non-leaf node with c children contains c − 1 search keys which act as separation values  to divide its sub-trees', '  • all leaf nodes appear in the same level, and carry information', '  there appears to be no deﬁnitive answer to the question of what the “b” in “b-tree” stands for', ' it is certainly not “binary”, but it could equally well be “balanced”, “broad” or “bushy”, or even “boeing” because they were invented by people at boeing research labs', '  the standard representation of simple order 4 example with 9 search keys would be:  the search keys held in each node are ordered (e', 'g', ', 1, 2, 5 in the example), and the non-leaf node’s search keys (i', 'e', ', the items 8 and 17 in the example) act as separation values to divide  49  \x0cthe contents of its sub-trees in much the same way that a node’s value in a binary search tree separates the values held in its two sub-trees', ' for example, if a node has 3 child nodes (or sub-trees) then it must have 2 separation values s1 and s2', ' all values in the leftmost subtree will be less than s1, all values in the middle subtree will be between s1 and s2, and all values in the rightmost subtree will be greater than s2', ' that allows insertion and searching to proceed from the root down in a similar way to binary search trees', '  the restriction on the number of children to lie between m/2 and m means that the best case height of an order m b-tree containing n search keys is logmn and the worst case height is logm/2n', ' clearly the costs of insertion, deletion and searching will all be proportional to the tree height, as in a binary search tree, which makes them very eﬃcient', ' the requirement that all the leaf nodes are at the same level means that b-trees are always balanced and thus have minimal height, though rebalancing will often be required to restore that property after insertions and deletions', '  the order of a b-tree is typically chosen to optimize a particular application and imple- mentation', ' to maintain the conditions of the b-tree deﬁnition, non-leaf nodes often have to be split or joined when new items are inserted into or deleted from the tree (which is why there is a factor of two between the minimum and maximum number of children), and rebal- ancing is often required', ' this renders the insertion and deletion algorithms somewhat more complicated than for binary search trees', ' an advantage of b-trees over self balancing binary search trees, however, is that the range of child nodes means that rebalancing is required less frequently', ' a disadvantage is that there may be more space wastage because nodes will rarely be completely full', ' there is also the cost of keeping the items within each node ordered, and having to search among them, but for reasonably small orders m, that cost is low', ' exercise: ﬁnd some suitable insertion, deletion and rebalancing algorithms for b-trees', '  50  \x0cchapter 8  priority queues and heap trees  8', '1 trees stored in arrays  it was noted earlier that binary trees can be stored with the help of pointer -like structures, in which each item contains references to its children', ' if the tree in question is a complete binary tree, there is a useful array based alternative', '  deﬁnition', ' a binary tree is complete if every level, except possibly the last, is completely ﬁlled, and all the leaves on the last level are placed as far to the left as possible', '  intuitively, a complete binary tree is one that can be obtained by ﬁlling the nodes starting with the root, and then each next level in turn, always from the left, until one runs out of nodes', ' complete binary trees always have minimal height for their size n, namely log2 n, and are always perfectly balanced (but not every perfectly balanced tree is complete in the sense of the above deﬁnition)', ' moreover, and more importantly, it is possible for them to be stored straightforwardly in arrays, top-to-bottom left-to-right, as in the following example:  for complete binary trees, such arrays provide very tight representations', '  notice that this time we have chosen to start the array with index 1 rather than 0', ' this has several computational advantages', ' the nodes on level i then have indices 2i, · · · , 2i+1 − 1', ' the level of a node with index i is (cid:98)log2 i(cid:99), that is, log2 i rounded down', ' the children of a node with index i, if they exist, have indices 2i and 2i + 1', ' the parent of a child with index i has index i/2 (using integer division)', ' this allows the following simple algorithms:  boolean isroot(int i) {  return i == 1  }  51  a[4]a[5]a[6]a[7]a[2]a[3]a[1]\x0cint level(int i) { return log(i)  int parent(int i) { return i / 2  int left(int i) { return 2 * i  int right(int i) {  return 2 * i + 1  }  }  }  }  which make the processing of these trees much easier', '  this way of storing a binary tree as an array, however, will not be eﬃcient if the tree is not complete, because it involves reserving space in the array for every possible node in the tree', ' since keeping binary search trees balanced is a diﬃcult problem, it is therefore not really a viable option to adapt the algorithms for binary search trees to work with them stored as arrays', ' array-based representations will also be ineﬃcient for binary search trees because node insertion or deletion will usually involve shifting large portions of the array', ' however, we shall now see that there is another kind of binary tree for which array-based representations allow very eﬃcient processing', '  8', '2 priority queues and binary heap trees  while most queues in every-day life operate on a ﬁrst come, ﬁrst served basis, it is sometimes important to be able to assign a priority to the items in the queue, and always serve the item with the highest priority next', ' an example of this would be in a hospital casualty department, where life-threatening injuries need to be treated ﬁrst', ' the structure of a complete binary tree in array form is particularly useful for representing such priority queues', '  it turns out that these queues can be implemented eﬃciently by a particular type of complete binary tree known as a binary heap tree', ' the idea is that the node labels, which were the search keys when talking about binary search trees, are now numbers representing the priority of each item in question (with higher numbers meaning a higher priority in our examples)', ' with heap trees, it is possible to insert and delete elements eﬃciently without having to keep the whole tree sorted like a binary search tree', ' this is because we only ever want to remove one element at a time, namely the one with the highest priority present, and the idea is that the highest priority item will always be found at the root of the tree', '  deﬁnition', ' a binary heap tree is a complete binary tree which is either empty or satisﬁes the following conditions:  • the priority of the root is higher than (or equal to) that of its children', '  • the left and right subtrees of the root are heap trees', '  52  \x0calternatively, one could deﬁne a heap tree as a complete binary tree such that the priority of every node is higher than (or equal to) that of all its descendants', ' or, as a complete binary tree for which the priorities become smaller along every path down through the tree', '  the most obvious diﬀerence between a binary heap tree and a binary search trees is that the biggest number now occurs at the root rather than at the right-most node', ' secondly, whereas with binary search trees, the left and right sub-trees connected to a given parent node play very diﬀerent rˆoles, they are interchangeable in binary heap trees', '  three examples of binary trees that are valid heap trees are:  and three which are not valid heap trees are:  the ﬁrst because 5 > 4 violates the required priority ordering, the second because it is not perfectly balanced and hence not complete, and the third because it is not complete due to the node on the last level not being as far to the left as possible', '  8', '3 basic operations on binary heap trees  in order to develop algorithms using an array representation, we need to allocate memory and keep track of the largest position that has been ﬁlled so far, which is the same as the current number of nodes in the heap tree', ' this will involve something like:  int max = 100 int heap[max+1] // stores priority values of nodes of heap tree // largest position that has been filled so far int n = 0  // maximum number of nodes allowed  for heap trees to be a useful representation of priority queues, we must be able to insert new nodes (or customers) with a given priority, delete unwanted nodes, and identify and remove the top-priority node, i', 'e', ' the root (that is, ‘serve’ the highest priority customer)', ' we also need to be able to determine when the queue/tree is empty', ' thus, assuming the priorities are given by integers, we need a constructor, mutators/selectors, and a condition:  insert(int p, array heap, int n) delete(int i, array heap, int n) int root(array heap, int n) boolean heapempty(array heap, int n)  53  identifying whether the heap tree is empty, and getting the root and last leaf, is easy:  144260707596171044728090988139321654365436543\x0cboolean heapempty(array heap, int n) {  return n == 0  }  }  }  int root(array heap, int n) { if ( heapempty(heap,n) )  error(‘heap is empty’)  else return heap[1]  int lastleaf(array heap, int n) {  if ( heapempty(heap,n) )  error(‘heap is empty’)  else return heap[n]  inserting and deleting heap tree nodes is also straightforward, but not quite so easy', '  8', '4  inserting a new heap tree node  since we always keep track of the last position n in the tree which has been ﬁlled so far, we can easily insert a new element at position n + 1, provided there is still room in the array, and increment n', ' the tree that results will still be a complete binary tree, but the heap tree priority ordering property might have been violated', ' hence we may need to ‘bubble up’ the new element into a valid position', ' this can be done easily by comparing its priority with that of its parent, and if the new element has higher priority, then it is exchanged with its parent', ' we may have to repeat this process, but once we reach a parent that has higher or equal priority, we can stop because we know there can be no lower priority items further up the tree', ' hence an algorithm which inserts a new heap tree node with priority p is:  insert(int p, array heap, int n) {  if ( n == max ) {  error(‘heap is full’)  else {  heap[n+1] = p bubbleup(n+1,heap,n+1)  }  }  }  }  bubbleup(int i, array heap, int n) {  if ( isroot(i) )  return  elseif ( heap[i] > heap[parent(i)] ) { swap heap[i] and heap[parent(i)] bubbleup(parent(i),heap,n)  54  \x0cnote that this insert algorithm does not increment the heap size n – that has to be done separately by whatever algorithm calls it', '  inserting a node takes at most o(log2 n) steps, because the maximum number of times we  may have to ‘bubble up’ the new element is the height of the tree which is log2 n', '  8', '5 deleting a heap tree node  to use a binary heap tree as a priority queue, we will regularly need to delete the root, i', 'e', ' remove the node with the highest priority', ' we will then be left with something which is not a binary tree at all', ' however, we can easily make it into a complete binary tree again by taking the node at the ‘last’ position and using that to ﬁll the new vacancy at the root', ' however, as with insertion of a new item, the heap tree (priority ordering) property might be violated', ' in that case, we will need to ‘bubble down’ the new root by comparing it with both its children and exchanging it with the largest', ' this process is then repeated until the new root element has found a valid place', ' thus, a suitable algorithm is:  a similar process can also be applied if we need to delete any other node from the heap tree, but in that case we may need to ‘bubble up’ the shifted last node rather than bubble it down', ' since the original heap tree is ordered, items will only ever need to be bubbled up or down, never both, so we can simply call both, because neither procedure changes anything if it is not required', ' thus, an algorithm which deletes any node i from a heap tree is:  deleteroot(array heap, int n) {  if ( n < 1 )  else {  error(‘node does not exist’)  heap[1] = heap[n] bubbledown(1,heap,n-1)  }  }  }  }  delete(int i, array heap, int n) {  if ( n < i )  else {  error(‘node does not exist’)  heap[i] = heap[n] bubbleup(i,heap,n-1) bubbledown(i,heap,n-1)  the bubble down process is more diﬃcult to implement than bubble up, because a node may have none, one or two children, and those three cases have to be handled diﬀerently', ' in the case of two children, it is crucial that when both children have higher priority than the given node, it is the highest priority one that is swapped up, or their priority ordering will be violated', ' thus we have:  55  \x0cbubbledown(int i, array heap, int n) {  if ( left(i) > n )  return  // no children  elseif ( right(i) > n )  // only left child  if ( heap[i] < heap[left(i)] )  swap heap[i] and heap[left(i)]  else  // two children  if ( heap[left(i)] > heap[right(i)] and heap[i] < heap[left(i)] ) {  swap heap[i] and heap[left(i)] bubbledown(left(i),heap,n)  elseif ( heap[i] < heap[right(i)] ) {  swap heap[i] and heap[right(i)] bubbledown(right(i),heap,n)  }  }  }  }  in the same way that the insert algorithm does not increment the heap size, this delete algorithm does not decrement the heap size n – that has to be done separately by whatever algorithm calls it', ' note also that this algorithm does not attempt to be fair in the sense that if two or more nodes have the same priority, it is not necessarily the one that has been waiting longest that will be removed ﬁrst', ' however, this factor could easily be ﬁxed, if required, by keeping track of arrival times and using that in cases of equal priority', '  as with insertion, deletion takes at most o(log2 n) steps, because the maximum number of times it may have to bubble down or bubble up the replacement element is the height of the tree which is log2 n', '  8', '6 building a new heap tree from scratch  sometimes one is given a whole set of n new items in one go, and there is a need to build a binary heap tree containing them', ' in other words, we have a set of items that we wish to heapify', ' one obvious possibility would be to insert the n items one by one into a heap tree, starting from an empty tree, using the o(log2 n) ‘bubble up’ based insert algorithm discussed earlier', ' that would clearly have overall time complexity of o(nlog2 n)', '  it turns out, however, that rearranging an array of items into heap tree form can be done more eﬃciently using ‘bubble down’', ' first note that, if we have the n items in an array a in positions 1, ', ' ', ' ', ' , n, then all the items with an index greater than n/2 will be leaves, and not need bubbling down', ' therefore, if we just bubble down all the non-leaf items a[n/2],', '', '', ', a[1] by exchanging them with the larger of their children until they either are positioned at a leaf, or until their children are both smaller, we obtain a valid heap tree', '  consider a simple example array if items from which a heap tree must be built:  5  8  3  9  1  4  7  6  2  we can start by simply drawing the array as a tree, and see that the last 5 entries (those with indices greater than 9/2 = 4) are leaves of the tree, as follows:  56  \x0cthen the rearrangement algorithm starts by bubbling down a[n/2] = a[4] = 9, which turns out not to be necessary, so the array remains the same', ' next a[3] = 3 is bubbled down, swapping with a[7] = 7, giving:  next a[2] = 8 is bubbled down, swapping with a[4] = 9, giving:  finally, a[1] = 5 is bubbled down, swapping with a[2] = 9, to give ﬁrst:  5  8  7  9  1  4  3  6  2  5  9  7  8  1  4  3  6  2  9  5  7  8  1  4  3  6  2  9  8  7  5  1  4  3  6  2  9  8  7  6  1  4  3  5  2  then swapping with a[4] = 8 to give:  and ﬁnally swapping with a[8] = 6 to give:  which has the array rearranged as the required heap tree', '  thus, using the above bubbledown procedure, the algorithm to build a complete binary  heap tree from any given array a of size n is simply:  heapify(array a, int n) {  for( i = n/2 ; i > 0 ; i-- )  bubbledown(i,a,n)  }  the time complexity of this heap tree creation algorithm might be computed as follows: it potentially bubbles down (cid:98)n/2(cid:99) items, namely those with indices 1, ', ' ', ' ', ' , (cid:98)n/2(cid:99)', ' the maximum number of bubble down steps for each of those items is the height of the tree, which is log2 n, and each step involves two comparisons – one to ﬁnd the highest priority child node, and one to compare the item with that child node', ' so the total number of comparisons involved is at most (n/2)', 'log2 n', '2 = nlog2 n, which is the same as we would have by inserting the array items one at a time into an initially empty tree', '  in fact, this is a good example of a situation in which a naive counting of loops and tree heights over-estimates the time complexity', ' this is because the number of bubble down steps  57  962147835\x0cwill usually be less than the full height of the tree', ' in fact, at each level as you go down the tree, there are more nodes, and fewer potential bubble down steps, so the total number of operations will actually be much less than nlog2 n', ' to be sure of the complexity class, we need to perform a more accurate calculation', ' at each level i of a tree of height h there will be 2i nodes, with at most h − i bubble down steps, each with 2 comparisons, so the total number of comparisons for a tree of height h will on average be  the ﬁnal sum converges to 2 as h increases (see appendix a', '4), so for large h we have  c(h) =  2i(h − i) = 2h  h (cid:88)  i=0  h (cid:88)  i=0  h − i 2h−i = 2h  h (cid:88)  j=0  j 2j  c(h) ≈ 2h  ∞ (cid:88)  j=0  j 2j = 2h', '2 = 2h+1 ≈ n  and the worst case will be no more than twice that', ' thus, the total number of operations is o(2h+1) = o(n), meaning that the complexity class of heapify is actually o(n), which is better than the o(nlog2 n) complexity of inserting the items one at a time', '  8', '7 merging binary heap trees  frequently one needs to merge two existing priority queues based on binary heap trees into a single priority queue', ' to achieve this, there are three obvious ways of merging two binary heap trees s and t of a similar size n into a single binary heap tree:  1', ' move all the items from the smaller heap tree one at a time into the larger heap tree using the standard insert algorithm', ' this will involve moving o(n) items, and each of them will need to be bubbled up at cost o(log2 n), giving an overall time complexity of o(nlog2 n)', '  2', ' repeatedly move the last items from one heap tree to the other using the standard insert algorithm, until the new binary tree maketree(0,t,s) is complete', ' then move the last item of the new tree to replace the dummy root “0”, and bubble down that new root', ' how this is best done will depend on the sizes of the two trees, so this algorithm is not totally straightforward', ' on average, around half the items in the last level of one tree will need moving and bubbling, so that will be o(n) moves, each with a cost of o(log2 n), again giving an overall time complexity of o(nlog2 n)', ' however, the actual number of operations required will, on average, be a lot less than the previous approach, by something like a factor of four, so this approach is more eﬃcient, even though the algorithm is more complex', '  3', ' simply concatenate the array forms of the heap trees s and t and use the standard heapify algorithm to convert that array into a new binary heap tree', ' the heapify algorithm has time complexity o(n), and the concatenation need be no more than that, so this approach has o(n) overall time complexity, making it in the best general approach of all three', '  thus, the merging of binary heap trees generally has o(n) time complexity', '  58  \x0cif the two binary heap trees are such that very few moves are required for the second approach, then that may look like a better choice of approach than the third approach', ' however, maketree will itself generally be an o(n) procedure if the trees are array-based, rather than pointer-based, which they usually are for binary heap trees', ' so, for array-based similarly-sized binary heaps, the third approach is usually best', '  if the heap trees to be merged have very diﬀerent sizes n and m < n, the ﬁrst approach will have overall time complexity o(mlog2 n), which could be more eﬃcient than an o(n) approach if m (cid:28) n', ' in practice, a good general purpose merge algorithm would check the sizes of the two trees and use them to determine the best approach to apply', '  8', '8 binomial heaps  a binomial heap is similar to a binary heap as described above, but has the advantage of more eﬃcient procedures for insertion and merging', ' unlike a binary heap, which consists of a single binary tree, a binomial heap is implemented as a collection of binomial trees', '  deﬁnition', ' a binomial tree is deﬁned recursively as follows:  • a binomial tree of order 0 is a single node', '  • a binomial tree of order k has a root node with children that are roots of binomial trees  of orders k − 1, k − 2, ', '', '', ', 2, 1, 0 (in that order)', '  thus, a binomial tree of order k has height k, contains 2k nodes, and is trivially constructed by attaching one order k−1 binomial tree as the left-most child of another order k−1 binomial tree', ' binomial trees of order 0, 1, 2 and 3 take the form:  and it is clear from these what higher order trees will look like', '  a binomial heap is constructed as a collection of binomial trees with a particular structure  and node ordering properties:  • there can only be zero or one binomial tree of each order', '  • each constituent binomial tree must satisfy the priority ordering property, i', 'e', ' each node  must have priority less than or equal to its parent', '  59  \x0cthe structure of such a heap is easily understood by noting that a binomial tree of order k contains exactly 2k nodes, and a binomial heap can only contain zero or one binomial tree of each order, so the total number of nodes in a binomial heap must be  n =  bk2k  bk ∈ [0, 1]  ∞ (cid:88)  k=0  where bk speciﬁes the number of trees of order k', ' thus there is a one-to-one mapping between the binomial heap structure and the standard binary representation of the number n, and since the binary representation is clearly unique, so is the binomial heap structure', ' the maximum number of trees in a heap with n nodes therefore equals the number of digits when n is written in binary without leading zeros, i', 'e', ' log2 n + 1', ' the heap can be stored eﬃciently as a linked list of root nodes ordered by increasing tree order', '  the most important operation for binomial heaps is merge, because that can be used as a sub-process for most other operations', ' underlying that is the merge of two binomial trees of order j into a binomial tree of order j + 1', ' by deﬁnition, that is achieved by adding one of those trees as the left most sub-tree of the root of the other, and preservation of the priority ordering simply requires that it is the tree with the highest priority root that provides the root of the combined tree', ' this clearly has o(1) time complexity', ' then merging two whole binomial heaps is achieved by merging the constituent trees whenever there are two of the same order, in a sequential manner analogous to the addition of two binary numbers', ' in this case, the o(1) insert complexity will be multiplied by the number of trees, which is o(log2 n), so the overall time complexity of merge is o(log2 n)', ' this is better than the o(n) complexity of merging binary heaps that can be achieved by concatenating the heap arrays and using the o(n) heapify algorithm', '  insertion of a new element into an existing binomial heap can easily be done by treating the new element as a binomial heap consisting of a single node (i', 'e', ', an order zero tree), and merging that using the standard merge algorithm', ' the average time complexity of that insert is given by computing the average number of o(1) tree combinations required', ' the probability of needing the order zero combination is 0', '5, the probability of needing a second combination is 0', '52, and the third is 0', '53, and so on, which sum to one', ' so insertion has o(1) overall time complexity', ' that is better than the o(log2 n) complexity of insertion into a standard binary heap', '  creating a whole new binomial heap from scratch can be achieved by using the o(1) insert process for each of the n items, giving an overall time complexity of o(n)', ' in this case, there is no better process, so heapify here has the same time complexity as the heapify algorithm for binary heaps', '  another important heap operation in practice is that of updating the heap after increas- ing a node priority', ' for standard binary heaps, that simply requires application of the usual bubble-up process with o(log2 n) complexity', ' clearly, a similar process can be used in bino- mial heaps, and that will also be of o(log2 n) complexity', '  the highest priority node in a binomial heap will clearly be the highest priority root node, and a pointer to that can be maintained by each heap update operation without increasing the complexity of the operation', ' serving the highest priority item requires deleting the highest priority node from the order j tree it appears in, and that will break it up into another binomial heap consisting of trees of all orders from 0 to j − 1', ' however, those trees can easily be merged back into the original heap using the standard merge algorithm, with the  60  \x0cstandard merge complexity of o(log2 n)', ' deleting non-root nodes can also be achieved with the existing operations by increasing the relevant node priority to inﬁnity, bubbling-up, and using the root delete operation, again with o(log2 n) complexity overall', ' so, the complexity of delete is always o(log2 n)', '  exercise: find pseudocode versions of the merge, insert and delete algorithms for binomial  heaps, and see exactly how their time complexities arise', '  8', '9 fibonacci heaps  a fibonacci heap is another collection of trees that satisfy the standard priority-ordering property', ' it can be used to implement a priority queue in a similar way to binary or binomial heaps, but the structure of fibonacci heaps are more ﬂexible and eﬃcient, which allows them to have better time complexities', ' they are named after the fibonacci numbers that restrict the tree sizes and appear in their time complexity analysis', '  the ﬂexibility and eﬃciency of fibonacci heaps comes at the cost of more complexity: the trees do not have a ﬁxed shape, and in the extreme cases every element in the heap can be in a separate tree', ' normally, the roots of all the trees are stored using a circular doubly linked list, and the children of each node are handled in the same way', ' a pointer to the highest priority root node is maintained, making it trivial to ﬁnd the highest priority node in the heap', ' the eﬃciency is achieved by performing many operations in a lazy manner, with much of the work postponed for later operations to deal with', '  fibonacci heaps can easily be merged with o(1) complexity by simply concatenating the two lists of root nodes, and then insertion can be done by merging the existing heap with a new heap consisting only of the new node', ' by inserting n items one at a time, a whole heap can be created from scratch with o(n) complexity', '  obviously, at some point, order needs to be introduced into the heap to achieve the overall eﬃciency', ' this is done by keeping the number of children of all nodes to be at most o(log2 n), and the size of a subtree rooted in a node with k children is at least fk+2, where fk is the kth fibonacci number', ' the number of trees in the heap is decreased as part of the delete operation that is used to remove the highest priority node and update the pointer to the highest priority root', ' this delete algorithm is quite complex', ' first it removes the highest priority root, leaving its children to become roots of new trees within the heap, the processing of which will be o(log2 n)', ' then the number of trees is reduced by linking together trees that have roots with the same number of children, similar to a binomial heap, until every root has a diﬀerent number of children, leaving at most o(log2 n) trees', ' finally the roots of those trees are checked to reset the pointer to the highest priority', ' it can be shown that all the required processes can be completed with o(log2 n) average time complexity', '  for each node, a record is kept of its number of children and whether it is marked', ' the mark indicates that at least one of its children has been separated since the node was made a child of another node, so all roots are unmarked', ' the mark is used by the algorithm for increasing a node priority, which is also complex, but can be achieved with o(1) complexity', ' this gives fibonacci heaps an important advantage over both binary and binomial heaps for which this operation has o(log2 n) time complexity', '  finally, an arbitrary node can be deleted from the heap by increasing its node priority to inﬁnity and applying the delete highest priority algorithm, resulting in an overall time complexity of o(log2 n)', '  61  \x0cexercise: find pseudocode versions of the various fibonacci heap operations, and work  out how fibonacci numbers are involved in computing their time complexities', '  8', '10 comparison of heap time complexities  it is clear that the more complex binomial and fibonacci heaps oﬀer average time complexity advantages over simple binary heap trees', ' the following table summarizes the average time complexities of the crucial heap operations:  heap type binary binomial fibonacci  insert  delete  o(log2 n) o(log2 n)  merge o(n)  o(1) o(1)  o(log2 n) o(log2 n) o(log2 n)  o(1)  heapify up priority o(log2 n) o(log2 n) o(1)  o(n) o(n) o(n)  obviously it will depend on the application in question whether using a more complicated heap is worth the eﬀort', ' we shall see later that fibonacci heaps are important in practice because they are used in the most eﬃcient versions of many algorithms that can be implemented using priority queues, such as dijkstra’s algorithm for ﬁnding shortest routes, and prim’s algorithm for ﬁnding minimal spanning trees', '  62  \x0cchapter 9  sorting  9', '1 the problem of sorting  in computer science, ‘sorting’ usually refers to bringing a set of items into some well-deﬁned order', ' to be able to do this, we ﬁrst need to specify the notion of order on the items we are considering', ' for example, for numbers we can use the usual numerical order (that is, deﬁned by the mathematical ‘less than’ or ‘<’ relation) and for strings the so-called lexicographic or alphabetic order, which is the one dictionaries and encyclopedias use', '  usually, what is meant by sorting is that once the sorting process is ﬁnished, there is a simple way of ‘visiting’ all the items in order, for example to print out the contents of a database', ' this may well mean diﬀerent things depending on how the data is being stored', ' for example, if all the objects are sorted and stored in an array a of size n, then  for i = 0,', '', '', ',n-1 print(a[i])  would print the items in ascending order', ' if the objects are stored in a linked list, we would expect that the ﬁrst entry is the smallest, the next the second-smallest, and so on', ' often, more complicated structures such as binary search trees or heap trees are used to sort the items, which can then be printed, or written into an array or linked list, as desired', '  sorting is important because having the items in order makes it much easier to ﬁnd a given item, such as the cheapest item or the ﬁle corresponding to a particular student', ' it is thus closely related to the problem of search, as we saw with the discussion of binary search tress', ' if the sorting can be done beforehand (oﬀ-line), this enables faster access to the required item, which is important because that often has to be done on the ﬂy (on-line)', ' we have already seen that, by having the data items stored in a sorted array or binary search tree, we can reduce the average (and worst case) complexity of searching for a particular item to o(log2 n) steps, whereas it would be o(n) steps without sorting', ' so, if we often have to look up items, it is worth the eﬀort to sort the whole collection ﬁrst', ' imagine using a dictionary or phone book in which the entries do not appear in some known logical order', '  it follows that sorting algorithms are important tools for program designers', ' diﬀerent algorithms are suited to diﬀerent situations, and we shall see that there is no ‘best’ sorting algorithm for everything, and therefore a number of them will be introduced in these notes', ' it is worth noting that we will be far from covering all existing sorting algorithms – in fact, the ﬁeld is still very much alive, and new developments are taking place all the time', ' however,  63  \x0cthe general strategies can now be considered to be well-understood, and most of the latest new algorithms tend to be derived by simply tweaking existing principles, although we still do not have accurate measures of performance for some sorting algorithms', '  9', '2 common sorting strategies  one way of organizing the various sorting algorithms is by classifying the underlying idea, or ‘strategy’', ' some of the key strategies are:  enumeration sorting  consider all items', ' if we know that there are n items which are smaller than the one we are currently considering, then its ﬁnal position will be at number n + 1', '  exchange sorting  if two items are found to be out of order, exchange them', ' repeat till all items are in order', '  selection sorting  find the smallest item, put it in the ﬁrst position, ﬁnd the smallest of the remaining items, put it in the second position ', ' ', ' ', '  insertion sorting  divide and conquer  take the items one at a time and insert them into an initially empty data structure such that the data structure continues to be sorted at each stage', '  recursively split the problem into smaller sub-problems till you just have single items that are trivial to sort', ' then put the sorted ‘parts’ back together in a way that preserves the sorting', '  all these strategies are based on comparing items and then rearranging them accordingly', ' these are known as comparison-based sorting algorithms', ' we will later consider other non- comparison-based algorithms which are possible when we have speciﬁc prior knowledge about the items that can occur, or restrictions on the range of items that can occur', '  the ideas above are based on the assumption that all the items to be sorted will ﬁt into the computer’s internal memory, which is why they are often referred to as being internal sorting algorithms', ' if the whole set of items cannot be stored in the internal memory at one time, diﬀerent techniques have to be used', ' these days, given the growing power and memory of computers, external storage is becoming much less commonly needed when sorting, so we will not consider external sorting algorithms in detail', ' suﬃce to say, they generally work by splitting the set of items into subsets containing as many items as can be handled at one time, sorting each subset in turn, and then carefully merging the results', '  9', '3 how many comparisons must it take?  an obvious way to compute the time complexity of sorting algorithms is to count the number of comparisons they need to carry out, as a function of the number of items to be sorted', ' there is clearly no general upper bound on the number of comparisons used, since a particularly stupid algorithm might compare the same two items indeﬁnitely', ' we are more interested in having a lower bound for the number of comparisons needed for the best algorithm in the worst case', ' in other words, we want to know the minimum number of comparisons required  64  \x0cto have all the information needed to sort an arbitrary collection of items', ' then we can see how well particular sorting algorithms compare against that theoretical lower bound', '  in general, questions of this kind are rather hard, because of the need to consider all pos- sible algorithms', ' in fact, for some problems, optimal lower bounds are not yet known', ' one important example is the so-called travelling salesman problem (tsp), for which all algo- rithms, which are known to give the correct shortest route solution, are extremely ineﬃcient in the worst case (many to the extent of being useless in practice)', ' in these cases, one generally has to relax the problem to ﬁnd solutions which are probably approximately correct', ' for the tsp, it is still an open problem whether there exists a feasible algorithm that is guaranteed to give the exact shortest route', '  for sorting algorithms based on comparisons, however, it turns out that a tight lower bound does exist', ' clearly, even if the given collection of items is already sorted, we must still check all the items one at a time to see whether they are in the correct order', ' thus, the lower bound must be at least n, the number of items to be sorted, since we need at least n steps to examine every element', ' if we already knew a sorting algorithm that works in n steps, then we could stop looking for a better algorithm: n would be both a lower bound and an upper bound to the minimum number of steps, and hence an exact bound ', ' however, as we shall shortly see, no algorithm can actually take fewer than o(nlog2 n) comparisons in the worst case', ' if, in addition, we can design an algorithm that works in o(nlog2 n) steps, then we will have obtained an exact bound', ' we shall start by demonstrating that every algorithm needs at least o(nlog2 n) comparisons', '  to begin with, let us assume that we only have three items, i, j, and k', ' if we have found that i ≤ j and j ≤ k, then we know that the sorted order is: i, j, k', ' so it took us two comparisons to ﬁnd this out', ' in some cases, however, it is clear that we will need as many as three comparisons', ' for example, if the ﬁrst two comparisons tell us that i > j and j ≤ k, then we know that j is the smallest of the three items, but we cannot say from this information how i and k relate', ' a third comparison is needed', ' so what is the average and worst number of comparisons that are needed? this can best be determined from the so-called decision tree, where we keep track of the information gathered so far and count the number of comparisons needed', ' the decision tree for the three item example we were discussing is:  so what can we deduce from this about the general case? the decision tree will obviously always be a binary tree', ' it is also clear that its height will tell us how many comparisons will be needed in the worst case, and that the average length of a path from the root to a leaf will give us the average number of comparisons required', ' the leaves of the decision tree are  65  i <= kj <= kj <= ki <= ki <= jk <= i <= ji <= k <= ji <= j <= kj <= i <= kk <= j <= ij <= k <= iyesyesnoyesnonoyesnoyesno\x0call the possible outcomes', ' these are given by the diﬀerent possible orders we can have on n items, so we are asking how many ways there are of arranging n items', ' the ﬁrst item can be any of the n items, the second can be any of the remaining n − 1 items, and so forth, so their total number is n(n − 1)(n − 2) · · · 3 · 2 · 1 = n!', ' thus we want to know the height h of a binary tree that can accommodate as many as n! leaves', ' the number of leaves of a tree of height h is at most 2h, so we want to ﬁnd h such that  2h ≥ n!  or  h ≥ log2 (n!)  there are numerous approximate expressions that have been derived for log2 (n!) for large n, but they all have the same dominant term, namely nlog2 n', ' (remember that, when talking about time complexity, we ignore any sub-dominant terns and constant factors', ') hence, no sorting algorithm based on comparing items can have a better average or worst case performance than using a number of comparisons that is approximately nlog2 n for large n', ' it remains to be seen whether this o(nlog2 n) complexity can actually be achieved in practice', ' to do this, we would have to exhibit at least one algorithm with this performance behaviour (and convince ourselves that it really does have this behaviour)', ' in fact, we shall shortly see that there are several algorithms with this behaviour', '  we shall proceed now by looking in turn at a number of sorting algorithms of increasing sophistication, that involve the various strategies listed above', ' the way they work depends on what kind of data structure contains the items we wish to sort', ' we start with approaches that work with simple arrays, and then move on to using more complex data structures that lead to more eﬃcient algorithms', '  9', '4 bubble sort  bubble sort follows the exchange sort approach', ' it is very easy to implement, but tends to be particularly slow to run', ' assume we have array a of size n that we wish to sort', ' bubble sort starts by comparing a[n-1] with a[n-2] and swaps them if they are in the wrong order', ' it then compares a[n-2] and a[n-3] and swaps those if need be, and so on', ' this means that once it reaches a[0], the smallest entry will be in the correct place', ' it then starts from the back again, comparing pairs of ‘neighbours’, but leaving the zeroth entry alone (which is known to be correct)', ' after it has reached the front again, the second-smallest entry will be in place', ' it keeps making ‘passes’ over the array until it is sorted', ' more generally, at the ith stage bubble sort compares neighbouring entries ‘from the back’, swapping them as needed', ' the item with the lowest index that is compared to its right neighbour is a[i-1]', ' after the ith stage, the entries a[0],', '', '', ',a[i-1] are in their ﬁnal position', '  at this point it is worth introducing a simple ‘test-case’ of size n = 4 to demonstrate how  the various sorting algorithms work:  2  1  bubble sort starts by comparing a[3]=2 with a[2]=3', ' since they are not in order, it swaps them, giving 4 3 ', ' it then compares a[2]=2 with a[1]=1', ' since those are in order, it leaves them where they are', ' then it compares a[1]=1 with a[0]=4, and those are not in 3 ', ' note that the smallest order once again, so they have to be swapped', ' we get 1 entry has reached its ﬁnal place', ' this will always happen after bubble sort has done its ﬁrst ‘pass’ over the array', '  4  2  4  1  3  2  66  \x0cnow that the algorithm has reached the zeroth entry, it starts at the back again, comparing a[3]=3 with a[2]=2', ' these entries are in order, so nothing happens', ' (note that these numbers have been compared before – there is nothing in bubble sort that prevents it from repeating comparisons, which is why it tends to be pretty slow!) then it compares a[2]=2 and a[1]=4', ' these are not in order, so they have to be swapped, giving 1 3 ', ' since we already know that a[0] contains the smallest item, we leave it alone, and the second pass is ﬁnished', ' note that now the second-smallest entry is in place, too', '  2  4  the algorithm now starts the third and ﬁnal pass, comparing a[3]=3 and a[2]=4', ' again these are out of order and have to be swapped, giving 1 4 ', ' since it is known that a[0] and a[1] contain the correct items already, they are not touched', ' furthermore, the third-smallest item is in place now, which means that the fourth-smallest has to be correct, too', ' thus the whole array is sorted', '  2  3  it is now clear that bubble sort can be implemented as follows:  for ( i = 1 ; i < n ; i++ )  for ( j = n-1 ; j >= i ; j-- )  if ( a[j] < a[j-1] )  swap a[j] and a[j-1]  the outer loop goes over all n − 1 positions that may still need to be swapped to the left, and the inner loop goes from the end of the array back to that position', '  as is usual for comparison-based sorting algorithms, the time complexity will be measured by counting the number of comparisons that are being made', ' the outer loop is carried out n − 1 times', ' the inner loop is carried out (n − 1) − (i − 1) = n − i times', ' so the number of comparisons is the same in each case, namely  n−1 (cid:88)  n−1 (cid:88)  i=1  j=i  n−1 (cid:88)  i=1  1 =  (n − i)  = (n − 1) + (n − 2) + · · · + 1  =  n(n − 1) 2  ', '  thus the worst case and average case number of comparisons are both proportional to n2, and hence the average and worst case time complexities are o(n2)', '  9', '5 insertion sort  insertion sort is (not surprisingly) a form of insertion sorting', ' it starts by treating the ﬁrst entry a[0] as an already sorted array, then checks the second entry a[1] and compares it with the ﬁrst', ' if they are in the wrong order, it swaps the two', ' that leaves a[0],a[1] sorted', ' then it takes the third entry and positions it in the right place, leaving a[0],a[1],a[2] sorted, and so on', ' more generally, at the beginning of the ith stage, insertion sort has the entries a[0],', '', '', ', a[i-1] sorted and inserts a[i], giving sorted entries a[0],', '', '', ',a[i]', '  for the example starting array 4  2 , insertion sort starts by considering a[0]=4 as sorted, then picks up a[1] and ‘inserts it’ into the already sorted array, increasing the size of it by 1', ' since a[1]=1 is smaller than a[0]=4, it has to be inserted in the zeroth slot,  3  1  67  \x0cbut that slot is holding a value already', ' so we ﬁrst move a[0] ‘up’ one slot into a[1] (care being taken to remember a[1] ﬁrst!), and then we can move the old a[1] to a[0], giving  1  4  3  2 ', '  at the next step, the algorithm treats a[0],a[1] as an already sorted array and tries to insert a[2]=3', ' this value obviously has to ﬁt between a[0]=1 and a[1]=4', ' this is achieved by moving a[1] ‘up’ one slot to a[2] (the value of which we assume we have remembered), allowing us to move the current value into a[1], giving 1  2 ', '  3  4  finally, a[3]=2 has to be inserted into the sorted array a[0],', '', '', ',a[2]', ' since a[2]=4 is bigger than 2, it is moved ‘up’ one slot, and the same happens for a[1]=3', ' comparison with a[0]=1 shows that a[1] was the slot we were looking for, giving 1  4 ', '  3  2  the general algorithm for insertion sort can therefore be written:  the outer loop goes over the n − 1 items to be inserted, and the inner loop takes each next item and swaps it back through the currently sorted portion till it reaches its correct position', ' however, this typically involves swapping each next item many times to get it into its right position, so it is more eﬃcient to store each next item in a temporary variable t and only insert it into its correct position when that has been found and its content moved:  for ( i = 1 ; i < n ; i++ ) { for( j = i ; j > 0 ; j-- ) if ( a[j] < a[j-1] )  swap a[j] and a[j-1]  else break  }  }  for ( i = 1 ; i < n ; i++ ) {  j = i t = a[j] while ( j > 0 && t < a[j-1] ) {  a[j] = a[j-1] j--  } a[j] = t  the outer loop again goes over n−1 items, and the inner loop goes back through the currently sorted portion till it ﬁnds the correct position for the next item to be inserted', '  the time complexity is again taken to be the number of comparisons performed', ' the outer loop is always carried out n − 1 times', ' how many times the inner loop is carried out depends on the items being sorted', ' in the worst case, it will be carried out i times; on average, it will be half that often', ' hence the number of comparison in the worst case is:  n−1 (cid:88)  i (cid:88)  i=1  j=1  1 =  n−1 (cid:88)  i  i=1  = 1 + 2 + · · · + (n − 1)  =  n(n − 1) 2  ;  68  \x0cand in the average case it is half that, namely n(n − 1)/4', ' thus average and worst case number of steps for of insertion sort are both proportional to n2, and hence the average and worst case time complexities are both o(n2)', '  9', '6 selection sort  selection sort is (not surprisingly) a form of selection sorting', ' it ﬁrst ﬁnds the smallest item and puts it into a[0] by exchanging it with whichever item is in that position already', ' then it ﬁnds the second-smallest item and exchanges it with the item in a[1]', ' it continues this way until the whole array is sorted', ' more generally, at the ith stage, selection sort ﬁnds the ith-smallest item and swaps it with the item in a[i-1]', ' obviously there is no need to check for the ith-smallest item in the ﬁrst i − 1 elements of the array', '  3  for the example starting array 4  2 , selection sort ﬁrst ﬁnds the smallest item in 1 the whole array, which is a[1]=1, and swaps this value with that in a[0] giving 1 2 ', ' then, for the second step, it ﬁnds the smallest item in the reduced array a[1],a[2],a[3], that is a[3]=2, and swaps that into a[1], giving 1 4 ', ' finally, it ﬁnds the smallest of the reduced array a[2],a[3], that is a[2]=3, and swaps that into a[2], or recognizes that a swap is not needed, giving 1  4 ', '  2  3  2  3  3  4  the general algorithm for selection sort can be written:  for ( i = 0 ; i < n-1 ; i++ ) {  k = i for ( j = i+1 ; j < n ; j++ )  if ( a[j] < a[k] )  k = j swap a[i] and a[k]  }  the outer loop goes over the ﬁrst n − 1 positions to be ﬁlled, and the inner loop goes through the currently unsorted portion to ﬁnd the next smallest item to ﬁll the next position', ' note that, unlike with bubble sort and insertion sort, there is exactly one swap for each iteration of the outer loop,  the time complexity is again the number of comparisons carried out', ' the outer loop is carried out n − 1 times', ' in the inner loop, which is carried out (n − 1) − i = n − 1 − i times, one comparison occurs', ' hence the total number of comparisons is:  n−2 (cid:88)  n−1 (cid:88)  i=0  j=i+1  n−2 (cid:88)  i=0  1 =  (n − 1 − i)  = (n − 1) + · · · + 2 + 1  =  n(n − 1) 2  ', '  therefore the number of comparisons for selection sort is proportional to n2, in the worst case as well as in the average case, and hence the average and worst case time complexities are both o(n2)', '  note that bubblesort, insertion sort and selection sort all involve two nested for loops over o(n) items, so it is easy to see that their overall complexities will be o(n2) without having to compute the exact number of comparisons', '  69  \x0c9', '7 comparison of o(n2) sorting algorithms  we have now seen three diﬀerent array based sorting algorithms, all based on diﬀerent sorting strategies, and all with o(n2) time complexity', ' so one might imagine that it does not make much diﬀerence which of these algorithms is used', ' however, in practice, it can actually make a big diﬀerence which algorithm is chosen', ' the following table shows the measured running times of the three algorithms applied to arrays of integers of the size given in the top row:  algorithm bubble sort insertion sort selection sort  128 54 15 12  256 221 69 45  512 881 276 164  1024 o1024 r1024 5627 1285 3621 2200 6 1137 833 643 634  2048 14497 4536 2497  here o1024 denotes an array with 1024 entries which are already sorted, and r1024 is an array which is sorted in the reverse order, that is, from biggest to smallest', ' all the other arrays were ﬁlled randomly', ' warning: tables of measurements like this are always dependent on the random ordering used, the implementation of the programming language involved, and on the machine it was run on, and so will never be exactly the same', '  so where exactly do these diﬀerences come from? for a start, selection sort always makes n(n − 1)/2 comparisons, but carries out at most n − 1 swaps', ' each swap requires three assignments and takes, in fact, more time than a comparison', ' bubble sort, on the other hand, does a lot of swaps', ' insertion sort does particularly well on data which is sorted already – in such a case, it only makes n − 1 comparisons', ' it is worth bearing this in mind for some applications, because if only a few entries are out of place, insertion sort can be very quick', ' these comparisons serve to show that complexity considerations can be rather delicate, and require good judgement concerning what operations to count', ' it is often a good idea to run some experiments to test the theoretical considerations and see whether any simpliﬁcations made are realistic in practice', ' for instance, we have assumed here that all comparisons cost the same, but that may not be true for big numbers or strings of characters', '  what exactly to count when considering the complexity of a particular algorithm is always a judgement call', ' you will have to gain experience before you feel comfortable with making such decisions yourself', ' furthermore, when you want to improve the performance of an algorithm, you may want to determine the biggest user of computing resources and focus on improving that', ' something else to be aware of when making these calculations is that it is not a bad idea to keep track of any constant factors, in particular those that go with the dominating sub-term', ' in the above examples, the factor applied to the dominating sub-term, namely n2, varies', ' it is 1/2 for the average case of bubble sort and selection sort, but only 1/4 for insertion sort', ' it is certainly useful to know that an algorithm that is linear will perform better than a quadratic one provided the size of the problem is large enough, but if you know that your problem has a size of, say, at most 100, then a complexity of (1/20)n2 will be preferable to one of 20n', ' or if you know that your program is only ever used on fairly small samples, then using the simplest algorithm you can ﬁnd might be beneﬁcial overall – it is easier to program, and there is not a lot of compute time to be saved', '  finally, the above numbers give you some idea why, for program designers, the general rule is to never use bubble sort', ' it is certainly easy to program, but that is about all it has going for it', ' you are better oﬀ avoiding it altogether', '  70  \x0c9', '8 sorting algorithm stability  one often wants to sort items which might have identical keys (e', 'g', ', ages in years) in such a way that items with identical keys are kept in their original order, particularly if the items have already been sorted according to a diﬀerent criteria (e', 'g', ', alphabetical)', ' so, if we denote the original order of an array of items by subscripts, we want the subscripts to end up in order for each set of items with identical keys', ' for example, if we start out with the array [51, 42, 63, 54, 65, 76, 57, 28, 99], it should be sorted to [28, 42, 51, 54, 57, 63, 65, 76, 99] and not to [28, 42, 54, 51, 57, 63, 65, 76, 99]', ' sorting algorithms which satisfy this useful property are said to be stable', '  the easiest way to determine whether a given algorithm is stable is to consider whether the algorithm can ever swap identical items past each other', ' in this way, the stability of the sorting algorithms studied so far can easily be established:  bubble sort  this is stable because no item is swapped past another unless they are in the wrong order', ' so items with identical keys will have their original order preserved', '  insertion sort  this is stable because no item is swapped past another unless it has a smaller key', ' so items with identical keys will have their original order preserved', '  selection sort  this is not stable, because there is nothing to stop an item being swapped past another item that has an identical key', ' for example, the array [21, 22, 13] would be sorted to [13, 22, 21] which has items 22 and 21 in the wrong order', '  the issue of sorting stability needs to be considered when developing more complex sorting algorithms', ' often there are stable and non-stable versions of the algorithms, and one has to consider whether the extra cost of maintaining stability is worth the eﬀort', '  9', '9 treesort  let us now consider a way of implementing an insertion sorting algorithm using a data structure better suited to the problem', ' the idea here, which we have already seen before, involves inserting the items to be sorted into an initially empty binary search tree', ' then, when all items have been inserted, we know that we can traverse the binary search tree to visit all the items in the right order', ' this sorting algorithm is called treesort, and for the basic version, we require that all the search keys be diﬀerent', '  obviously, the tree must be kept balanced in order to minimize the number of comparisons, since that depends on the height of the tree', ' for a balanced tree that is o(log2 n)', ' if the tree is not kept balanced, it will be more than that, and potentially o(n)', '  treesort can be diﬃcult to compare with other sorting algorithms, since it returns a tree, rather than an array, as the sorted data structure', ' it should be chosen if it is desirable to have the items stored in a binary search tree anyway', ' this is usually the case if items are frequently deleted or inserted, since a binary search tree allows these operations to be implemented eﬃciently, with time complexity o(log2 n) per item', ' moreover, as we have seen before, searching for items is also eﬃcient, again with time complexity o(log2 n)', '  71  \x0ceven if we have an array of items to start with, and want to ﬁnish with a sorted array, we can still use treesort', ' however, to output the sorted items into the original array, we will need another procedure fillarray(tree t, array a, int j) to traverse the tree t and ﬁll the array a', ' that is easiest done by passing and returning an index j that keeps track of the next array position to be ﬁlled', ' this results in the complete treesort algorithm:  treesort(array a) { t = emptytree for ( i = 0 ; i < size(a) ; i++ )  t = insert(a[i],t)  fillarray(t,a,0)  fillarray(tree t, array a, int j) {  if ( not isempty(t) ) {  j = fillarray(left(t),a,j) a[j++] = root(t) j = fillarray(right(t),a,j)  } return j  }  }  which assumes that a is a pointer to the array location and that its elements can be accessed and updated given that and the relevant array index', '  since there are n items to insert into the tree, and each insertion has time complexity o(log2 n), treesort has an overall average time complexity of o(nlog2 n)', ' so, we already have one algorithm that achieves the theoretical best average case time complexity of o(nlog2 n)', ' note, however, that if the tree is not kept balanced while the items are being inserted, and the items are already sorted, the height of the tree and number of comparisons per insertion will be o(n), leading to a worst case time complexity of o(n2), which is no better than the simpler array-based algorithms we have already considered', '  exercise: we have assumed so far that the items stored in a binary search tree must not contain any duplicates', ' find the simplest ways to relax that restriction and determine how the choice of approach aﬀects the stability of the associated treesort algorithm', '  9', '10 heapsort  we now consider another way of implementing a selection sorting algorithm using a more eﬃcient data structure we have already studied', ' the underlying idea here is that it would help if we could pre-arrange the data so that selecting the smallest/biggest entry becomes easier', ' for that, remember the idea of a priority queue discussed earlier', ' we can take the value of each item to be its priority and then queue the items accordingly', ' then, if we remove the item with the highest priority at each step we can ﬁll an array in order ‘from the rear’, starting with the biggest item', '  priority queues can be implemented in a number of diﬀerent ways, and we have already studied a straightforward implementation using binary heap trees in chapter 8', ' however, there may be a better way, so it is worth considering the other possibilities', '  72  \x0can obvious way of implementing them would be using a sorted array, so that the entry with the highest priority appears in a[n]', ' removing this item would be very simple, but inserting a new item would always involve ﬁnding the right position and shifting a number of items to the right to make room for it', ' for example, inserting a 3 into the queue [1, 2, 4]:  n a[n]  n a[n]  n a[n]  0 1  0 1  0 1  1 2  1 2  1 2  2 4  2  2 3  3  4  5  4  5  4  5  3 4  3 4  that kind of item insertion is eﬀectively insertion sort and clearly ineﬃcient in general, of o(n) complexity rather than o(log2 n) with a binary heap tree', '  another approach would be to use an unsorted array', ' in this case, a new item would be inserted by just putting it into a[n+1], but to delete the entry with the highest priority would involve having to ﬁnd it ﬁrst', ' then, after that, the last item would have to be swapped into the gap, or all items with a higher index ‘shifted down’', ' again, that kind of item deletion is clearly ineﬃcient in general, of o(n) complexity rather than o(log2 n) with a heap tree', '  thus, of those three representations, only one is of use in carrying out the above idea eﬃciently', ' an unsorted array is what we started from, so that is not any help, and ordering the array is what we are trying to achieve, so heaps are the way forward', '  to make use of binary heap trees, we ﬁrst have to take the unsorted array and re-arrange it so that it satisﬁes the heap tree priority ordering', ' we have already studied the heapify algorithm which can do that with o(n) time complexity', ' then we need to extract the sorted array from it', ' in the heap tree, the item with the highest priority, that is the largest item, is always in a[1]', ' in the sorted array, it should be in the last position a[n]', ' if we simply swap the two, we will have that item at the right position of the array, and also have begun the standard procedure of removing the root of the heap-tree, since a[n] is precisely the item that would be moved into the root position at the next step', ' since a[n] now contains the correct item, we will never have to look at it again', ' instead, we just take the items a[1],', '', '', ',a[n-1] and bring them back into a heap-tree form using the bubble down procedure on the new root, which we know to have complexity o(log2 n)', '  now the second largest item is in position a[1], and its ﬁnal position should be a[n-1], so we now swap these two items', ' then we rearrange a[1],', '', '', ',a[n-2] back into a heap tree using the bubble down procedure on the new root', ' and so on', '  when the ith step has been completed, the items a[n-i+1],', '', '', ',a[n] will have the correct entries, and there will be a heap tree for the items a[1],', '', '', ',a[n-i]', ' note that the size, and therefore the height, of the heap tree decreases at each step', ' as a part of the ith step, we have to bubble down the new root', ' this will take at most twice as many comparisons as the height of the original heap tree, which is log2 n', ' so overall there are n − 1 steps, with at most 2log2 n comparisons, totalling 2(n − 1)log2 n', ' the number of comparisons will actually be less than that, because the number of bubble down steps will usually be less than the full height of the tree, but usually not much less, so the time complexity is still o(nlog2 n)', '  the full heapsort algorithm can thus be written in a very simple form, using the bubble down and heapify procedures we already have from chapter 8', ' first heapify converts the  73  \x0carray into a binary heap tree, and then the for loop moves each successive root one item at a time into the correct position in the sorted array:  heapsort(array a, int n) {  heapify(a,n) for( j = n ; j > 1 ; j-- ) {  swap a[1] and a[j] bubbledown(1,a,j-1)  }  }  it is clear from the swap step that the order of identical items can easily be reversed, so there is no way to render the heapsort algorithm stable', '  the average and worst-case time complexities of the entire heapsort algorithm are given by the sum of two complexity functions, ﬁrst that of heapify rearranging the original unsorted array into a heap tree which is o(n), and then that of making the sorted array out of the heap tree which is o(nlog2 n) coming from the o(n) bubble-downs each of which has o(log2 n) complexity', ' thus the overall average and worst-case complexities are both o(nlog2 n), and we now have a sorting algorithm that achieves the theoretical best worst-case time complex- ity', ' using more sophisticated priority queues, such as binomial or fibonacci heaps, cannot improve on this because they have the same delete time complexity', '  a useful feature of heapsort is that if only the largest m (cid:28) n items need to be found and sorted, rather than all n, the complexity of the second stage is only o(mlog2 n), which can easily be less than o(n) and thus render the whole algorithm only o(n)', '  9', '11 divide and conquer algorithms  all the sorting algorithms considered so far work on the whole set of items together', ' instead, divide and conquer algorithms recursively split the sorting problem into more manageable sub-problems', ' the idea is that it will usually be easier to sort many smaller collections of items than one big one, and sorting single items is trivial', ' so we repeatedly split the given collection into two smaller parts until we reach the ‘base case’ of one-item collections, which require no eﬀort to sort, and then merge them back together again', ' there are two main approaches for doing this:  assuming we are working on an array a of size n with entries a[0],', '', '', ',a[n-1], then the obvious approach is to simply split the set of indices', ' that is, we split the array at item n/2 and consider the two sub-arrays a[0],', '', '', ',a[(n-1)/2] and a[(n+1)/2],', '', '', ',a[n-1]', ' this method has the advantage that the splitting of the collection into two collections of equal (or nearly equal) size at each stage is easy', ' however, the two sorted arrays that result from each split have to be merged together carefully to maintain the ordering', ' this is the underlying idea for a sorting algorithm called mergesort', '  another approach would be to split the array in such a way that, at each stage, all the items in the ﬁrst collection are no bigger than all the items in the second collection', ' the splitting here is obviously more complex, but all we have to do to put the pieces back together again at each stage is to take the ﬁrst sorted array followed by the second sorted array', ' this is the underlying idea for a sorting algorithm called quicksort', '  we shall now look in detail at how these two approaches work in practice', '  74  \x0c9', '12 quicksort  the general idea here is to repeatedly split (or partition) the given array in such a way that all the items in the ﬁrst sub-array are smaller than all the items in the second sub-array, and then concatenate all the sub-arrays to give the sorted full array', '  how to partition', ' the important question is how to perform this kind of splitting most eﬃciently', ' if the array is very simple, for example [4,3,7,8,1,6], then a good split would be to put all the items smaller than 5 into one part, giving [4,3,1], and all the items bigger than or equal to 5 into the other, that is [7,8,6]', ' indeed, moving all items with a smaller key than some given value into one sub-array, and all entries with a bigger or equal key into the other sub-array is the standard quicksort strategy', ' the value that deﬁnes the split is called the pivot', ' however, it is not obvious what is the best way to choose the pivot value', '  one situation that we absolutely have to avoid is splitting the array into an empty sub- array and the whole array again', ' if we do this, the algorithm will not just perform badly, it will not even terminate', ' however, if the pivot is chosen to be an item in the array, and the pivot is kept in between and separate from both sub-arrays, then the sub-arrays being sorted at each recursion will always be at least one item shorter than the previous array, and the algorithm is guaranteed to terminate', '  thus, it proves convenient to split the array at each stage into the sub-array of values smaller than or equal to some chosen pivot item, followed by that chosen pivot item, followed by the sub-array of values greater than or equal to the chosen pivot item', ' moreover, to save space, we do not actually split the array into smaller arrays', ' instead, we simply rearrange the whole array to reﬂect the splitting', ' we say that we partition the array, and the quicksort algorithm is then applied to the sub-arrays of this partitioned array', '  in order for the algorithm to be called recursively, to sort ever smaller parts of the original array, we need to tell it which part of the array is currently under consideration', ' therefore, quicksort is called giving the lowest index (left) and highest index (right) of the sub-array it must work on', ' thus the algorithm takes the form:  quicksort(array a, int left, int right) {  if ( left < right ) {  pivotindex = partition(a,left,right) quicksort(a,left,pivotindex-1) quicksort(a,pivotindex+1,right)  }  }  for which the initial call would be quicksort(a,0,n-1) and the array a at the end is sorted', ' the crucial part of this is clearly the partition(a, left, right) procedure that rearranges the array so that it can be split around an appropriate pivot a[pivotindex]', '  if we were to split oﬀ only one item at a time, quicksort would have n recursive calls, where n is the number of items in the array', ' if, on the other hand, we halve the array at each stage, it would only need log2 n recursive calls', ' this can be made clear by drawing a binary tree whose nodes are labelled by the sub-arrays that have been split oﬀ at each stage, and measuring its height', ' ideally then, we would like to get two sub-arrays of roughly equal size (namely half of the given array) since that is the most eﬃcient way of doing this', ' of course, that depends on choosing a good pivot', '  75  \x0cif we get the pivot ‘just right’ (e', 'g', ', choosing 5 in the above example), choosing the pivot', ' then the split will be as even as possible', ' unfortunately, there is no quick guaranteed way of ﬁnding the optimal pivot', ' if the keys are integers, one could take the average value of all the keys, but that requires visiting all the entries to sample their key, adding considerable overhead to the algorithm, and if the keys are more complicated, such as strings, you cannot do this at all', ' more importantly, it would not necessarily give a pivot that is a value in the array', ' some sensible heuristic pivot choice strategies are:  • use a random number generator to produce an index k and then use a[k]', '  • take a key from ‘the middle’ of the array, that is a[(n-1)/2]', '  • take a small sample (e', 'g', ', 3 or 5 items) and take the ‘middle’ key of those', '  note that one should never simply choose the ﬁrst or last key in the array as the pivot, because if the array is almost sorted already, that will lead to the particularly bad choice mentioned above, and this situation is actually quite common in practice', '  since there are so many reasonable possibilities, and they are all fairly straightforward, we will not give a speciﬁc implementation for any of these pivot choosing strategies, but just assume that we have a choosepivot(a,left,right) procedure that returns the index of the pivot for a particular sub-array (rather than the pivot value itself)', '  the partitioning', ' in order to carry out the partitioning within the given array, some thought is required as to how this may be best achieved', ' this is more easily demonstrated by an example than put into words', ' for a change, we will consider an array of strings, namely the programming languages: [c, fortran, java, ada, pascal, basic, haskell, ocaml]', ' the ordering we choose is the standard lexicographic one, and let the chosen pivot be “fortran”', '  we will use markers | to denote a partition of the array', ' to the left of the left marker, there will be items we know to have a key smaller than or equal to the pivot', ' to the right of the right marker, there will be items we know to have a key bigger than or equal to the pivot', ' in the middle, there will be the items we have not yet considered', ' note that this algorithm proceeds to investigate the items in the array from two sides', '  we begin by swapping the pivot value to the end of the array where it can easily be kept separate from the sub-array creation process, so we have the array: [|c, ocaml, java, ada, pascal, basic, haskell | fortran]', ' starting from the left, we ﬁnd “c” is less than “fortran”, so we move the left marker one step to the right to give [c | ocaml, java, ada, pascal, basic, haskell | fortran]', ' now “ocaml” is greater than “fortran”, so we stop on the left and proceed from the right instead, without moving the left marker', ' we then ﬁnd “haskell” is bigger than “fortran”, so we move the right marker to the left by one, giving [c | ocaml, java, ada, pascal, basic, | haskell, fortran]', ' now “basic” is smaller than “fortran”, so we have two keys, “ocaml” and “basic”, which are ‘on the wrong side’', ' we therefore swap them, which allows us to move both the left and the right marker one step further towards the middle', ' this brings us to [c, basic | java, ada, pascal | ocaml, haskell, fortran]', ' now we proceed from the left once again, but “java” is bigger than “fortran”, so we stop there and switch to the right', ' then “pascal” is bigger than “fortran”, so we move the right marker again', ' we then ﬁnd “ada”, which is smaller than the pivot, so we stop', ' we have now got [c, basic | java, ada, | pascal, ocaml, haskell, fortran]', ' as before, we want to swap “java” and “ada”, which leaves the left and the right markers in the same place: [c, basic, ada, java | | pascal, ocaml, haskell, fortran], so we  76  \x0cstop', ' finally, we swap the pivot back from the last position into the position immediately after the markers to give [c, basic, ada, java | | fortran, ocaml, haskell, pascal]', '  since we obviously cannot have the marker indices ‘between’ array entries, we will as- sume the left marker is on the left of a[leftmark] and the right marker is to the right of a[rightmark]', ' the markers are therefore ‘in the same place’ once rightmark becomes smaller than leftmark, which is when we stop', ' if we assume that the keys are integers, we can write the partitioning procedure, that needs to return the ﬁnal pivot position, as:  partition(array a, int left, int right) {  pivotindex = choosepivot(a, left, right) pivot = a[pivotindex] swap a[pivotindex] and a[right] leftmark = left rightmark = right - 1 while (leftmark <= rightmark) {  while (leftmark <= rightmark and a[leftmark] <= pivot)  while (leftmark <= rightmark and a[rightmark] >= pivot)  leftmark++  rightmark--  if (leftmark < rightmark)  swap a[leftmark++] and a[rightmark--]  } swap a[leftmark] and a[right] return leftmark  }  this achieves a partitioning that ends with the same items in the array, but in a diﬀerent order, with all items to the left of the returned pivot position smaller or equal to the pivot value, and all items to the right greater or equal to the pivot value', '  note that this algorithm doesn’t require any extra memory – it just swaps the items in the original array', ' however, the swapping of items means the algorithm is not stable', ' to render quicksort stable, the partitioning must be done in such a way that the order of identical items can never be reversed', ' a conceptually simple approach that does this, but requires more memory and copying, is to simply go systematically through the whole array, re-ﬁlling the array a with items less than or equal to the pivot, and ﬁlling a second array b with items greater or equal to the pivot, and ﬁnally copying the array b into the end of a:  partition2(array a, int left, int right) { create new array b of size right-left+1 pivotindex = choosepivot(a, left, right) pivot = a[pivotindex] acount = left bcount = 1 for ( i = left ; i <= right ; i++ ) {  if ( i == pivotindex )  b[0] = a[i]  77  else if ( a[i] < pivot || (a[i] == pivot && i < pivotindex) )  \x0ca[acount++] = a[i]  else  b[bcount++] = a[i]  } for ( i = 0 ; i < bcount ; i++ )  a[acount++] = b[i] return right-bcount+1  }  like the ﬁrst partition procedure, this also achieves a partitioning with the same items in the array, but in a diﬀerent order, with all items to the left of the returned pivot position smaller or equal to the pivot value, and all items to the right greater or equal to the pivot value', '  complexity of quicksort', ' once again we shall determine complexity based on the number of comparisons performed', ' the partitioning step compares each of n items against the pivot, and therefore has complexity o(n)', ' clearly, some partition and pivot choice algorithms are less eﬃcient than others, like partition2 involving more copying of items than partition, but that does not generally aﬀect the overall complexity class', '  in the worst case, when an array is partitioned, we have one empty sub-array', '  if this happens at each step, we apply the partitioning method to arrays of size n, then n − 1, then n − 2, until we reach 1', ' those complexity functions then add up to  n + (n − 1) + (n − 2) + · · · 2 + 1 = n(n + 1)/2  ignoring the constant factor and the non-dominant term n/2, this shows that, in the worst case, the number of comparisons performed by quicksort is o(n2)', '  in the best case, whenever we partition the array, the resulting sub-arrays will diﬀer in size by at most one', ' then we have n comparisons in the ﬁrst case, two lots of (cid:98)n/2(cid:99) comparisons for the two sub-arrays, four times (cid:98)n/4(cid:99), eight times (cid:98)n/8(cid:99), and so on, down to 2log2 n−1 times (cid:98)n/2log2 n−1(cid:99) = (cid:98)2(cid:99)', ' that gives the total number of comparisons as  n + 21(cid:98)n/21(cid:99) + 22(cid:98)n/22(cid:99) + 23(cid:98)n/23(cid:99) + · · · + 2log2 n−1(cid:98)n/2log2 n−1(cid:99) ≈ nlog2 n  which matches the theoretical best possible time complexity of o(nlog2 n)', '  more interesting and important is how well quicksort does in the average case', ' however, that is much harder to analyze exactly', ' the strategy for choosing a pivot at each stage aﬀects that, though as long as it avoids the problems outlined above, that does not change the complexity class', ' it also makes a diﬀerence whether there can be duplicate values, but again that doesn’t change the complexity class', ' in the end, all reasonable variations involve comparing o(n) items against a pivot, for each of o(log2 n) recursions, so the total number of comparisons, and hence the overall time complexity, in the average case is o(nlog2 n)', '  like heapsort, when only the largest m (cid:28) n items need to be found and sorted, rather than all n, quicksort can be modiﬁed to result in reduced time complexity', ' in this case, only the ﬁrst sub-array needs to be processed at each stage, until the sub-array sizes exceed m', ' in that situation, for the best case, the total number of comparisons is reduced to  n + 1(cid:98)n/21(cid:99) + 1(cid:98)n/22(cid:99) + 1(cid:98)n/23(cid:99) + · · · + mlog2 m ≈ 2n', '  rendering the time complexity of the whole modiﬁed algorithm only o(n)', ' for the average case, the computation is again more diﬃcult, but as long as the key problems outlined above are avoided, the average-case complexity of this special case is also o(n)', '  78  \x0cit is always worthwhile spending some time optimizing the strategy improving quicksort', ' for deﬁning the pivot, since the particular problem in question might well allow for a more reﬁned approach', ' generally, the pivot will be better if more items are sampled before it is being chosen', ' for example, one could check several randomly chosen items and take the ‘middle’ one of those, the so called median', ' note that in order to ﬁnd the median of all the items, without sorting them ﬁrst, we would end up having to make n2 comparisons, so we cannot do that without making quicksort unattractively slow', '  quicksort is rarely the most suitable algorithm if the problem size is small', ' the reason for this is all the overheads from the recursion (e', 'g', ', storing all the return addresses and formal parameters)', ' hence once the sub-problem become ‘small’ (a size of 16 is often suggested in the literature), quicksort should stop calling itself and instead sort the remaining sub-arrays using a simpler algorithm such as selection sort', '  9', '13 mergesort  the other divide and conquer sorting strategy based on repeatedly splitting the array of items into two sub-arrays, mentioned in section 9', '11, is called mergesort', ' this simply splits the array at each stage into its ﬁrst and last half, without any reordering of the items in it', ' however, that will obviously not result in a set of sorted sub-arrays that we can just append to each other at the end', ' so mergesort needs another procedure merge that merges two sorted sub-arrays into another sorted array', ' as with binary search in section 4', '4, integer variables left and right can be used to refer to the lower and upper index of the relevant array, and mid refers to the end of its left sub-array', ' thus a suitable mergesort algorithm is:  mergesort(array a, int left, int right) {  if ( left < right ) {  mid = (left + right) / 2 mergesort(a, left, mid) mergesort(a, mid+1, right) merge(a, left, mid, right)  }  }  note that it would be relatively simple to modify this mergesort algorithm to operate on linked lists (of known length) rather than arrays', ' to ‘split’ such a list into two, all one has to do is set the pointer of the (cid:98)n/2(cid:99)th list entry to null, and use the previously-pointed-to next entry as the head of the new second list', ' of course, care needs to be taken to keep the list size information intact, and eﬀort is required to ﬁnd the crucial pointer for each split', '  the merge algorithm', ' the principle of merging two sorted collections (whether they be lists, arrays, or something else) is quite simple: since they are sorted, it is clear that the smallest item overall must be either the smallest item in the ﬁrst collection or the smallest item in the second collection', ' let us assume it is the smallest key in the ﬁrst collection', ' now the second smallest item overall must be either the second-smallest item in the ﬁrst collection, or the smallest item in the second collection, and so on', ' in other words, we just work through both collections and at each stage, the ‘next’ item is the current item in either the ﬁrst or the second collection', '  79  \x0cthe implementation will be quite diﬀerent, however, depending on which data structure we are using', ' when arrays are used, it is actually necessary for the merge algorithm to create a new array to hold the result of the operation at least temporarily', ' in contrast, when using linked lists, it would be possible for merge to work by just changing the reference to the next node', ' this does make for somewhat more confusing code, however', '  for arrays, a suitable merge algorithm would start by creating a new array b to store the results, then repeatedly add the next smallest item into it until one sub-array is ﬁnished, then copy the remainder of the unﬁnished sub-array, and ﬁnally copy b back into a:  merge(array a, int left, int mid, int right) { create new array b of size right-left+1 bcount = 0 lcount = left rcount = mid+1 while ( (lcount <= mid) and (rcount <= right) ) {  if ( a[lcount] <= a[rcount] )  b[bcount++] = a[lcount++]  else  b[bcount++] = a[rcount++]  } if ( lcount > mid )  while ( rcount <= right )  b[bcount++] = a[rcount++]  else  while ( lcount <= mid )  b[bcount++] = a[lcount++]  for ( bcount = 0 ; bcount < right-left+1 ; bcount++ )  a[left+bcount] = b[bcount]  }  it is instructive to compare this with the partition2 algorithm for quicksort to see exactly where the two sort algorithms diﬀer', ' as with partition2, the merge algorithm never swaps identical items past each other, and the splitting does not change the ordering at all, so the whole mergesort algorithm is stable', '  complexity of mergesort', ' the total number of comparisons needed at each recursion level of mergesort is the number of items needing merging which is o(n), and the number of recursions needed to get to the single item level is o(log2 n), so the total number of com- parisons and its time complexity are o(nlog2 n)', ' this holds for the worst case as well as the average case', ' like quicksort, it is possible to speed up mergesort by abandoning the recursive algorithm when the sizes of the sub-collections become small', ' for arrays, 16 would once again be a suitable size to switch to an algorithm like selection sort', '  note that, with mergesort, for the special case when only the largest/smallest m (cid:28) n items need to be found and sorted, rather than all n, there is no way to reduce the time complexity in the way it was possible with heapsort and quicksort', ' this is because the ordering of the required items only emerges at the very last stage after the large majority of the comparisons have already been carried out', '  80  \x0c9', '14 summary of comparison-based sorting algorithms  the following table summarizes the key properties of all the comparison-based sorting algo- rithms we have considered:  sorting algorithm bubble sort selection sort insertion sort treesort heapsort quicksort mergesort  strategy employed exchange selection insertion insertion selection d & c d & c  objects manipulated arrays arrays arrays/lists trees/lists arrays arrays arrays/lists  stable  worst case average case complexity o(n2) o(n2) o(n2) o(n2) o(nlog2 n) o(n2) o(nlog2 n)  complexity o(n2) o(n2) o(n2) o(nlog2 n) o(nlog2 n) o(nlog2 n) maybe o(nlog2 n)  yes no yes yes no  yes  to see what the time complexities mean in practice, the following table compares the typical run times of those of the above algorithms that operate directly on arrays:  algorithm bubble sort selection sort insertion sort heapsort quicksort quicksort2 mergesort mergesort2  128 54 12 15 21 12 6 18 6  256 221 45 69 45 27 12 36 22  512 881 164 276 103 55 24 88 48  1024 o1024 r1024 5627 1285 3621 833 643 634 2200 6 1137 249 215 236 1200 1131 112 1191 1115 57 170 166 188 93 94 112  2048 14497 2497 4536 527 230 134 409 254  as before, arrays of the stated sizes are ﬁlled randomly, except o1024 that denotes an array with 1024 entries which are already sorted, and r1024 that denotes an array which is sorted in the reverse order', ' quicksort2 and mergesort2 are algorithms where the recursive procedure is abandoned in favour of selection sort once the size of the array falls to 16 or below', ' it should be emphasized again that these numbers are of limited accuracy, since they vary somewhat depending on machine and language implementation', '  what has to be stressed here is that there is no ‘best sorting algorithm’ in general, but that there are usually good and bad choices of sorting algorithms for particular circumstances', ' it is up to the program designer to make sure that an appropriate one is picked, depending on the properties of the data to be sorted, how it is best stored, whether all the sorted items are required rather than some sub-set, and so on', '  9', '15 non-comparison-based sorts  all the above sorting algorithms have been based on comparisons of the items to be sorted, and we have seen that we can’t get time complexity better than o(nlog2 n) with comparison based algorithms', ' however, in some circumstances it is possible to do better than that with sorting algorithms that are not based on comparisons', '  81  \x0cit is always worth thinking about the data that needs to be sorted, and whether com- parisons really are required', ' for example, suppose you know the items to be sorted are the numbers from 0 to n − 1', ' how would you sort those? the answer is surprisingly simple', ' we know that we have n entries in the array and we know exactly which items should go there and in which order', ' this is a very unusual situation as far as general sorting is concerned, yet this kind of thing often comes up in every-day life', ' for example, when a hotel needs to sort the room keys for its 100 rooms', ' rather than employing one of the comparison-based sorting algorithms, in this situation we can do something much simpler', ' we can simply put the items directly in the appropriate places, using an algorithm such as that as shown in figure 9', '1:  create array b of size n for ( i = 0 ; i < n ; i++ )  b[a[i]] = a[i]  copy array b into array a  figure 9', '1: simply put the items in the right order using their values', '  this algorithm uses a second array b to hold the results, which is clearly not very memory eﬃcient, but it is possible to do without that', ' one can use a series of swaps within array a to get the items in the right positions as shown in figure 9', '2:  for ( i = 0 ; i < n; i++ ) {  while ( a[i] != i )  swap a[a[i]] and a[i]  }  figure 9', '2: swapping the items into the right order without using a new array', '  as far as time complexity is concerned, it is obviously not appropriate here to count the number of comparisons', ' instead, it is the number of swaps or copies that is important', ' the algorithm of figure 9', '1 performs n copies to ﬁll array b and then another n to return the result to array a, so the overall time complexity is o(n)', ' the time complexity of the algorithm of figure 9', '2 looks worse than it really is', ' this algorithm performs at most n − 1 swaps, since one item, namely a[a[i]] is always swapped into its ﬁnal position', ' so at worst, this has time complexity o(n) too', '  this example should make it clear that in particular situations, sorting might be per- formed by much simpler (and quicker) means than the standard comparison sorts, though most realistic situations will not be quite as simple as the case here', ' once again, it is the responsibility of the program designer to take this possibility into account', '  82  001324312430124013243102431024i=0i=1i=0i=2\x0c9', '16 bin, bucket, radix sorts  bin, bucket, and radix sorts are all names for essentially the same non-comparison-based sorting algorithm that works well when the items are labelled by small sets of values', ' for example, suppose you are given a number of dates, by day and month, and need to sort them into order', ' one way of doing this would be to create a queue for each day, and place the items (dates) one at a time into the right queue according to their day (without sorting them further)', ' then form one big queue out of these, by concatenating all the day queues starting with day 1 and continuing up to day 31', ' then for the second phase, create a queue for each month, and place the dates into the right queues in the order that they appear in the queue created by the ﬁrst phase', ' again form a big queue by concatenating these month queues in order', ' this ﬁnal queue is sorted in the intended order', '  this may seem surprising at ﬁrst sight, so let us consider a simple example:  [25/12, 28/08, 29/05, 01/05, 24/04, 03/01, 04/01, 25/04, 26/12, 26/04, 05/01, 20/04]', '  we ﬁrst create and ﬁll queues for the days as follows:  01: [01/05] 03: [03/01] 04: [04/01] 05: [05/01] 20: [20/04] 24: [24/04] 25: [25/12, 25/04] 26: [26/12, 26/04] 28: [28/08] 29: [29/05]  the empty queues are not shown – there is no need to create queues before we hit an item that belongs to them', ' then concatenation of the queues gives:  [01/05, 03/01, 04/01, 05/01, 20/04, 24/04, 25/12, 25/04, 26/12, 26/04,28/08, 29/05]', '  next we create and ﬁll queues for the months that are present, giving:  01: [03/01, 04/01, 05/01] 04: [20/04, 24/04, 25/04, 26/04] 05: [01/05, 29/05] 08: [28/08] 12: [25/12, 26/12]  finally, concatenating all these queues gives the items in the required order:  [03/01, 04/01, 05/01, 20/04, 24/04, 25/04, 26/04, 01/05, 29/05, 28/08, 25/12, 26/12]', '  this is called two-phase radix sorting, since there are clearly two phases to it', '  83  \x0cthe extension of this idea to give a general sorting algorithm should be obvious: for each phase, create an ordered set of queues corresponding to the possible values, then add each item in the order they appear to the end of the relevant queue, and ﬁnally concatenate the the queues in order', ' repeat this process for each sorting criterion', ' the crucial additional detail is that the queuing phases must be performed in the order of the signiﬁcance of each criteria, with the least signiﬁcant criteria ﬁrst', '  for example, if you know that your items to be sorted are all (at most) two-digit integers, you can use radix sort to sort them', ' first create and ﬁll queues for the last digit, concatenate, then create and ﬁll queues for the ﬁrst digit, and concatenate to leave the items in sorted order', ' similarly, if you know that your keys are all strings consisting of three characters, you can again apply radix sort', ' you would ﬁrst queue according to the third character, then the second, and ﬁnally the ﬁrst, giving a three phase radix sort', '  note that at no point, does the the algorithm actually compare any items at all', ' this kind of algorithm makes use of the fact that for each phase the items are from a strictly restricted set, or, in other words, the items are of a particular form which is known a priori', ' the complexity class of this algorithm is o(n), since at every phase, each item is dealt with precisely once, and the number of phases is assumed to be small and constant', ' if the restricted sets are small, the number of operations involved in ﬁnding the right queue for each item and placing it at the end of it will be small, but this could become signiﬁcant if the sets are large', ' the concatenation of the queues will involve some overheads, of course, but these will be small if the sets are small and linked lists, rather than arrays, are used', ' one has to be careful, however, because if the total number of operations for each item exceeds log2 n, then the overall complexity is likely to be greater than the o(nlog2 n) complexity of the more eﬃcient comparison-based algorithms', ' also, if the restricted sets are not known in advance, and potentially large, the overheads of ﬁnding and sorting them could render radix sort worse than using a comparison-based approach', ' once again, it is the responsibility of the program designer to decide whether a given problem can be solved more eﬃciently with radix sort rather than a comparison-based sort', '  84  \x0cchapter 10  hash tables  10', '1 storing data  we have already seen a number of diﬀerent ways of storing items in a computer: arrays and variants thereof (e', 'g', ', sorted and unsorted arrays, heap trees), linked lists (e', 'g', ', queues, stacks), and trees (e', 'g', ', binary search trees, heap trees)', ' we have also seen that these approaches can perform quite diﬀerently when it comes to the particular tasks we expect to carry out on the items, such as insertion, deletion and searching, and that the best way of storing data does not exist in general, but depends on the particular application', '  this chapter looks at another way of storing data, that is quite diﬀerent from the ones we have seen so far', ' the idea is to simply put each item in an easily determined location, so we never need to search for it, and have no ordering to maintain when inserting or deleting items', ' this has impressive performance as far as time is concerned, but that advantage is payed for by needing more space (i', 'e', ', memory), as well as by being more complicated and therefore harder to describe and implement', '  we ﬁrst need to specify what we expect to be able to do with this way of storing data, without considering how it is actually implemented', ' in other words, we need to outline an abstract data type', ' this is similar to what you will generally do when ﬁrst trying to implement a class in java: you should think about the operations you wish to perform on the objects of that class', ' you may also want to specify a few variables that you know will deﬁnitely be needed for that class, but this does not usually come into deﬁning an abstract data type', ' the approach we have been following for deﬁning abstract data types in these notes is by describing the crucial operations in plain english, trusting that they are simple enough to not need further explanations', ' in general, what is needed is a speciﬁcation for the abstract data type in question', ' an important aspect of studying software engineering is to learn about and use more formal approaches to this way of operating', '  after we have decided what our speciﬁcation is, we then need to choose a data structure in order to implement the abstract data type', ' the data structure to be considered in this chapter is a particular type of table known as a hash table', '  10', '2 the table abstract data type  the speciﬁcation of the table abstract data type is as follows:  1', ' a table can be used to store objects, for example  85  \x0cjohnny james  english bond rider  012 007 583 alex 721 sherlock holmes 722  james  spy spy spy detective  moriarty villain  2', ' the objects can be arbitrarily complicated', ' however, for our purposes, the only relevant detail is that each object has a unique key, and that their keys can be compared for equality', ' the keys are used in order to identify objects in much the way we have done for searching and sorting', '  3', ' we assume that there are methods or procedures for:  (a) determining whether the table is empty or full;  (b) inserting a new object into the table, provided the table is not already full;  (c) given a key, retrieving the object with that key;  (d) given a key, updating the item with that key (usually by replacing the item with a new one with the same key, which is what we will assume here, or by overwriting some of the item’s variables);  (e) given a key, deleting the object with that key, provided that object is already stored  in the table;  (f) listing or traversing all the items in the table (if there is an order on the keys then  we would expect this to occur in increasing order)', '  notice that we are assuming that each object is uniquely identiﬁed by its key', '  in a programming language such as java, we could write an interface for this abstract data type as follows, where we assume here that keys are objects of a class we call key and we have records of a class called record:  interface table {  boolean isempty(); boolean isfull(); void insert(record); record retrieve(key); void update(record); void delete{key}; void traverse();  }  note that we have not ﬁxed how exactly the storage of records should work – that is some- thing that comes with the implementation', ' also note that you could give an interface to somebody else, who could then write a program which performs operations on tables without ever knowing how they are implemented', ' you could certainly carry out all those operations with binary search trees and sorted or unsorted arrays if you wished', ' the former even has the advantage that a binary search tree never becomes full as such, because it is only limited by the size of the memory', '  this general approach follows the sensible and commonly used way to go about deﬁning a java class: first think about what it is you want to do with the class, and only then wonder  86  \x0cabout how exactly you might implement the methods', ' thus, languages such as java support mechanisms for deﬁning abstract data types', ' but notice that, as opposed to a speciﬁcation in plain english, such as the above, a deﬁnition of an interface is only a partial speciﬁcation of an abstract data type, because it does not explain what the methods are supposed to do; it only explains how they are called', '  10', '3 implementations of the table data structure  there are three key approaches for implementing the table data structure', ' the ﬁrst two we have studied already, and the third is the topic of this chapter:  implementation via sorted arrays', ' let us assume that we want to implement the table data structure using a sorted array', ' whether it is full or empty can easily be determined in constant time if we have a variable for the size', ' then to insert an element we ﬁrst have to ﬁnd its proper position, which will take on average the same time as ﬁnding an element', ' to ﬁnd an element (which is necessary for all other operations apart from traversal), we can use binary search as described in in section 4', '4, so this takes o(log2 n)', ' this is also the complexity for retrieval and update', ' however, if we wish to delete or insert an item, we will have to shift what is ‘to the right’ of the location in question by one, either to the left (for deletion) or to the right (for insertion)', ' this will take on average n/2 steps, so these operations have o(n) complexity', ' traversal in order is simple, and is of o(n) complexity as well', '  implementation via binary search trees a possible alternative implementation would involve using binary search trees', ' however, we know already that in the worst case, the tree can be very deep and narrow, and that these trees will have linear complexity when it comes to looking up an entry', ' we have seen that there is a variant of binary search trees which keeps the worst case the same as the average case, the so-called self-balancing binary search tree, but that is more complicated to both understand and program', ' for those trees, insertion, deletion, search, retrieval and update, can all be done with time complexity o(log2 n), and traversal has o(n) complexity', '  implementation via hash tables the idea here is that, at the expense of using more space than strictly needed, we can speed up the table operations', ' the remainder of this chapter will describe how this is done, and what the various computational costs are', '  10', '4 hash tables  the underlying idea of a hash table is very simple, and quite appealing: assume that, given a key, there was a way of jumping straight to the entry for that key', ' then we would never have to search at all, we could just go there! of course, we still have to work out a way for that to be achieved', ' assume that we have an array data to hold our entries', ' now if we had a function h(k) that maps each key k to the index (an integer) where the associated entry will be stored, then we could just look up data[h(k)] to ﬁnd the entry with the key k', '  it would be easiest if we could just make the data array big enough to hold all the keys that might appear', ' for example, if we knew that the keys were the numbers from 0 to 99, then we could just create an array of size 100 and store the entry with key 67 in data[67],  87  \x0cand so on', ' in this case, the function h would be the identity function h(k) = k', ' however, this idea is not very practical if we are dealing with a relatively small number of keys out of a huge collection of possible keys', ' for example, many american companies use their employees’ 9-digit social security number as a key, even though they have nowhere near 109 employees', ' british national insurance numbers are even worse, because they are just as long and usually contain a mixture of letters and numbers', ' clearly it would be very ineﬃcient, if not impossible, to reserve space for all 109 social security numbers which might occur', '  instead, we use a non-trivial function h, the so-called hash function, to map the space of possible keys to the set of indices of our array', ' for example, if we had to store entries about 500 employees, we might create an array with 1000 entries and use three digits from their social security number (maybe the ﬁrst or last three) to determine the place in the array where the records for each particular employee should be stored', '  this approach sounds like a good idea, but there is a pretty obvious problem with it: what happens if two employees happen to have the same three digits? this is called a collision between the two keys', ' much of the remainder of this chapter will be spent on the various strategies for dealing with such collisions', '  first of all, of course, one should try to avoid collisions', '  if the keys that are likely to actually occur are not evenly spread throughout the space of all possible keys, particular attention should be paid to choosing the hash function h in such a way that collisions among them are less likely to occur', ' if, for example, the ﬁrst three digits of a social security number had geographical meaning, then employees are particularly likely to have the three digits signifying the region where the company resides, and so choosing the ﬁrst three digits as a hash function might result in many collisions', ' however, that problem might easily be avoided by a more prudent choice, such as the last three digits', '  10', '5 collision likelihoods and load factors for hash tables  one might be tempted to assume that collisions do not occur very often when only a small subset of the set of possible keys is chosen, but this assumption is mistaken', '  the von mises birthday paradox', ' as an example, consider a collection of people, and a hash function that gives their birthdays as the number of the day in the year, i', 'e', ' 1st january is 1, 2nd january is 2, ', ' ', ' ', ' , 31st december is 365', ' one might think that if all we want to do is store a modest number of 24 people in this way in an array with 365 locations, collisions will be rather unlikely', ' however, it turns out that the probability of collision is bigger than 50%', ' this is so surprising at ﬁrst sight that this phenomenon has become known as the von mises birthday paradox , although it is not really a paradox in the strict sense', '  it is easy to understand what is happening', ' suppose we have a group of n people and want to ﬁnd out how likely it is that two of them have the same birthday, assuming that the birthdays are uniformly distributed over the 365 days of the year', ' let us call this probability p(n)', ' it is actually easier to ﬁrst compute the probability q(n) that no two of them share a birthday, and then p(n) = 1 − q(n)', ' for n = 1 this probability is clearly q(1) = 1', ' for n = 2 we get q(2) = 364/365 because, for the added second person, 364 of the 365 days are not the birthday of the ﬁrst person', ' for n = 3 we get  q(3) =  365 · 364 · 363 3653  = 1 − p(3)  88  \x0cand for the general n > 1 case we have  q(n) =  365 · 364 · 363 · · · (365 − n + 1) 365n  =  365! 365n(365 − n)!  = 1 − p(n)  it may be surprising that p(22) = 0', '476 and p(23) = 0', '507, which means that as soon as there are more than 22 people in a group, it is more likely that two of them share a birthday than not', ' note that in the real world, the distribution of birthdays over the year is not precisely uniform, but this only increases the probability that two people have the same birthday', ' in other words, birthday collisions are much more likely than one might think at ﬁrst', '  implications for hash tables', ' if 23 random locations in a table of size 365 have more than a 50% chance of overlapping, it seems inevitable that collisions will occur in any hash table that does not waste an enormous amount of memory', ' and collisions will be even more likely if the hash function does not distribute the items randomly throughout the table', '  to compute the computational eﬃciency of a hash table, we need some way of quantifying how full the table is, so we can compute the probability of collisions, and hence determine how much eﬀort will be required to deal with them', '  the load factor of a hash table', ' suppose we have a hash table of size m, and it currently has n entries', ' then we call λ = n/m the load factor of the hash table', ' this load factor is the obvious way of describing how full the table currently is: a hash table with load factor 0', '25 is 25% full, one with load factor 0', '50 is 50% full, and so on', ' then if we have a hash table with load factor λ, the probability that a collision occurs for the next key we wish to insert is λ', ' this assumes that each key from the key space is equally likely, and that the hash function h spreads the key space evenly over the set of indices of our array', ' if these optimistic assumptions fail, then the probability may be even higher', '  therefore, to minimize collisions, it is prudent to keep the load factor low', ' fifty percent is an often quoted good maximum ﬁgure, while beyond an eighty percent load the performance deteriorates considerably', ' we shall see later exactly what eﬀect the table’s load factor has on the speed of the operations we are interested in', '  10', '6 a simple hash table in operation  let us assume that we have a small data array we wish to use, of size 11, and that our set of possible keys is the set of 3-character strings, where each character is in the range from a to z', ' obviously, this example is designed to illustrate the principle – typical real-world hash tables are usually very much bigger, involving arrays that may have a size of thousands, millions, or tens of millions, depending on the problem', '  we now have to deﬁne a hash function which maps each string to an integer in the range 0 to 10', ' let us consider one of the many possibilities', ' we ﬁrst map each string to a number as follows: each character is mapped to an integer from 0 to 25 using its place in the alphabet (a is the ﬁrst letter, so it goes to 0, b the second so it goes to 1, and so on, with z getting value 25)', ' the string x1x2x3 therefore gives us three numbers from 0 to 25, say k1, k2, and k3', ' we can then map the whole string to the number calculated as  k = k1 ∗ 262 + k2 ∗ 261 + k3 ∗ 260 = k1 ∗ 262 + k2 ∗ 26 + k3', '  89  \x0cthat is, we think of the strings as coding numbers in base 26', '  now it is quite easy to go from any number k (rather than a string) to a number from 0 to 10', ' for example, we can take the remainder the number leaves when divided by 11', ' this is the c or java modulus operation k % 11', ' so our hash function is  h(x1x2x3) = (k1 ∗ 262 + k2 ∗ 26 + k3)%11 = k%11', '  this modulo operation, and modular arithmetic more generally, are widely used when con- structing good hash functions', '  as a simple example of a hash table in operation, assume that we now wish to insert the following three-letter airport acronyms as keys (in this order) into our hash table: phl, ory, gcm, hkg, gla, akl, fra, lax, dca', ' to make this easier, it is a good idea to start by listing the values the hash function takes for each of the keys:  code h(x1x2x3)  phl ory gcm hkg gla akl fra lax dca 8  8  4  7  5  4  6  1  1  it is clear already that we will have hash collisions to deal with', '  we naturally start oﬀ with an empty table of the required size, i', 'e', ' 11:  clearly we have to be able to tell whether a particular location in the array is still empty, or whether it has already been ﬁlled', ' we can assume that there is a unique key or entry (which is never associated with a record) which denotes that the position has not been ﬁlled yet', ' however, for clarity, this key will not appear in the pictures we use', '  now we can begin inserting the keys in order', ' the number associated with the ﬁrst item  phl is 4, so we place it at index 4, giving:  next is ory, which gives us the number 8, so we get:  phl  then we have gcm, with value 6, giving:  phl  ory  phl  gcm  ory  then hkg, which also has value 4, results in our ﬁrst collision since the corresponding position has already been ﬁlled with phl', ' now we could, of course, try to deal with this by simply saying the table is full, but this gives such poor performance (due to the frequency with which collisions occur) that it is unacceptable', '  10', '7 strategies for dealing with collisions  we now look at three standard approaches, of increasing complexity, for dealing with hash collisions:  90  \x0cbuckets', ' one obvious option is to reserve a two-dimensional array from the start', ' we can think of each column as a bucket in which we throw all the elements which give a particular result when the hash function is supplied, so the ﬁfth column contains all the keys for which the hash function evaluates to 4', ' then we could put hkg into the slot ‘beneath’ phl, and gla in the one beneath ory, and continue ﬁlling the table in the order given until we reach:  0  2  3  1 lax dca  4  5  6 phl fra gcm akl ory gla hkg  7  8  9  10  the disadvantage of this approach is that it has to reserve quite a bit more space than will be eventually required, since it must take into account the likely maximal number of collisions', ' even while the table is still quite empty overall, collisions will become increasingly likely', ' moreover, when searching for a particular key, it will be necessary to search the entire column associated with its expected position, at least until an empty slot is reached', ' if there is an order on the keys, they can be stored in ascending order, which means we can use the more eﬃcient binary search rather than linear search, but the ordering will have an overhead of its own', ' the average complexity of searching for a particular item depends on how many entries in the array have been ﬁlled already', ' this approach turns out to be slower than the other techniques we shall consider, so we shall not spend any more time on it, apart from noting that it does prove useful when the entries are held in slow external storage', '  direct chaining', ' rather than reserving entire sub-arrays (the columns above) for keys that collide, one can instead create a linked list for the set of entries corresponding to each key', ' the result for the above example can be pictured something like this:  this approach does not reserve any space that will not be taken up, but has the disadvantage that in order to ﬁnd a particular item, lists will have to be traversed', ' however, adding the hashing step still speeds up retrieval considerably', '  we can compute the size of the average non-empty list occurring in the hash table as follows', ' with n items in an array of size m, the probability than no items land in a particular slot is q(n, m) = ( m−1  m )n', ' so the number of slots with at least one item falling in it is  n (n, m) = m', '  1 − q(n, m)  = m', '  1 − (  (cid:16)  (cid:17)  (cid:16)  m − 1 m  )n(cid:17)  91  laxdcafragcmphlhkgaklorygla012345678910\x0cand since there are n items altogether, the average number of items in a non-empty list is:  then a linear search for an item in a list of size k takes on average  k(n, m) =  n n (n, m)  =  (cid:16)  n 1 − ( m−1  m )n(cid:17) ', '  m', '  (cid:16)  1 k  1 + 2 + · · · + k  =  (cid:17)  k(k + 1) 2k  =  k + 1 2  comparisons', ' it is diﬃcult to visualize what these formulae mean in practice, but if we assume the hash table is large but not overloaded, i', 'e', ' n and m are both large with n (cid:28) m, we can perform a taylor approximation for small loading factor λ = n/m', ' that shows there are  k + 1 2  = 1 +  +  + o(λ3)  λ 4  λ2 24  comparisons on average for a successful search, i', 'e', ' that this has o(1) complexity', '  for an unsuccessful search, we need the average list size including the empty slots', ' that will clearly be n/m = λ, and so in an unsuccessful search the average number of comparisons made to decide the item in question is not present will be λ, which is again o(1)', '  thus, neither the successful nor unsuccessful search times depend on the number of keys in the table, but only on the load factor, which can be kept low by choosing the size of the hash table to be big enough', ' note also that insertion is done even more speedily, since all we have to do is to insert a new element at the front of the appropriate list', ' hence, apart from traversal, the complexity class of all operations is constant, i', 'e', ' o(1)', ' for traversal, we need to sort the keys, which can be done in o(nlog2 n), as we know from chapter 9', ' a variant would be to make each linked list sorted, which will speed up ﬁnding an item, as well as speed up traversal slightly, although this will not put either operation into a diﬀerent complexity class', ' this speed-up would be paid for by making the insertion operation more expensive, i', 'e', ' take slightly longer, but it will still have constant complexity', '  overall, all the time complexities for this approach are clearly very impressive compared  to those for sorted arrays or (balanced) binary search trees', '  open addressing', ' the last fundamentally diﬀerent approach to collision avoidance is called open addressing, and that involves ﬁnding another open location for any entry which cannot be placed where its hash function points', ' we refer to that position as a key’s primary position (so in the earlier example, ory and gla have the same primary position)', ' the easiest strategy for achieving this is to search for open locations by simply decreasing the index considered by one until we ﬁnd an empty space', ' if this reaches the beginning of the array, i', 'e', ' index 0, we start again at the end', ' this process is called linear probing', ' a better approach is to search for an empty location using a secondary hash function', ' this process is called double hashing', ' we will now look at both of these approaches in some detail', '  10', '8 linear probing  we now proceed with the earlier example using linear probing', ' we had reached the stage:  phl  gcm  ory  92  \x0cand then wanted to put hkg at index 4, where we found phl', '  linear probing reduces the index by one to 3, and ﬁnds an empty location in that position,  so we put hkg there giving:  hkg phl  gcm  ory  next we wish to insert gla, with hash value 8, but the location with that index is already ﬁlled by ory', ' again linear probing reduces the index by one, and since that slot one to the left is free, we insert gla there:  hkg phl  gcm gla ory  then we have akl, and although we have not had the value 7 before, the corresponding location is ﬁlled by gla', ' so we try the next index down, but that contains gcm, so we continue to the next one at index 5 which s empty, so we put akl there:  hkg phl akl gcm gla ory  we now continue in the same way with the remaining keys, eventually reaching:  dca lax fra hkg phl akl gcm gla ory  this looks quite convincing - all the keys have been inserted in a way that seems to make good use of the space we have reserved', '  however, what happens now if we wish to ﬁnd a particular key? it will no longer be good enough to simply apply the hash function to it and check there', ' instead, we will have to follow its possible insertion locations until we hit an empty one, which tells us that the key we were looking for is not present, after all, because it would have been inserted there', ' this is why every hash table that uses open addressing should have at least one empty slot at any time, and be declared full when only one empty location is left', ' however, as we shall see, hash tables lose much of their speed advantage if they have a high load factor, so as a matter of policy, many more locations should be kept empty', '  so, to ﬁnd the key akl, we would ﬁrst check at index 7, then at 6, and 5, where we are successful', ' searching for jfk, on the other hand, we would start with its proper position, given by the hash function value 8, so we would check indices 8, 7, 6, ', ' ', ' ', ' , 1, 0, 10 in that order until we ﬁnd an empty space which tells us that jfk is, in fact, not present at all', ' this looks pretty bad at ﬁrst sight, but bear in mind that we said that we will aim towards keeping the load factor at around 50 percent, so there would be many more empty slots which eﬀectively stop any further search', '  but this idea brings another problem with it', ' suppose we now delete gcm from the table and then search for akl again', ' we would ﬁnd the array empty at index 6 and stop searching, and therefore wrongly conclude that akl is not present', ' this is clearly not acceptable, but equally, we do not wish to have to search through the entire array to be sure that an entry is not there', ' the solution is that we reserve another key to mean that a position is empty, but that it did hold a key at some point', ' let us assume that we use the character ‘!’ for that', ' then after deleting gcm, the array would be:  dca lax fra hkg phl akl  !  gla ory  93  \x0cand when searching for akl we would know to continue beyond the exclamation mark', ' if, on the other hand, we are trying to insert a key, then we can ignore any exclamation marks and ﬁll the position once again', ' this now does take care of all our problems, although if we do a lot of deleting and inserting, we will end up with a table which is a bit of a mess', ' a large number of exclamation marks means that we have to keep looking for a long time to ﬁnd a particular entry despite the fact that the load factor may not be all that high', ' this happens if deletion is a frequent operation', ' in such cases, it may be better to re-ﬁll a new hash table again from scratch, or use another implementation', '  search complexity', ' the complexity of open addressing with linear probing is rather dif- ﬁcult to compute, so we will not attempt to present a full account of it here', ' if λ is once again the load factor of the table, then a successful search can be shown to take 1 2 (1 + 1 1−λ ) comparisons on average, while an unsuccessful search takes approximately 1 2 (1 + 1 (1−λ)2 )', ' for relatively small load factors, this is quite impressive, and even for larger ones, it is not bad', ' thus, the hash table time complexity for search is again constant, i', 'e', ' o(1)', '  clustering', ' there is a particular problem with linear probing, namely what is known as primary and secondary clustering', ' consider what happens if we try to insert two keys that have the same result when the hash function is applied to them', ' take the above example with hash table at the stage where we just inserted gla:  hkg phl  gcm gla ory  if we next try to insert jfk we note that the hash function evaluates to 8 once again', ' so we keep checking the same locations we only just checked in order to insert gla', ' this seems a rather ineﬃcient way of doing this', ' this eﬀect is known as primary clustering because the new key jfk will be inserted close to the previous key with the same primary position, gla', ' it means that we get a continuous ‘block’ of ﬁlled slots, and whenever we try to insert any key which is sent into the block by the hash function, we will have to test all locations until we hit the end of the block, and then make such block even bigger by appending another entry at its end', ' so these blocks, or clusters, keep growing, not only if we hit the same primary location repeatedly, but also if we hit anything that is part of the same cluster', ' the last eﬀect is called secondary clustering', ' note that searching for keys is also adversely aﬀected by these clustering eﬀects', '  10', '9 double hashing  the obvious way to avoid the clustering problems of linear probing is to do something slightly more sophisticated than trying every position to the left until we ﬁnd an empty one', ' this is known as double hashing', ' we apply a secondary hash function to tell us how many slots to jump to look for an empty slot if a key’s primary position has been ﬁlled already', '  like the primary hash function, there are many possible choices of the secondary hash function', ' in the above example, one thing we could do is take the same number k associated with the three-character code, and use the result of integer division by 11, instead of the remainder, as the secondary hash function', ' however, the resulting value might be bigger than 10, so to prevent the jump looping round back to, or beyond, the starting point, we ﬁrst take  94  \x0cthe result of integer division by 11, and then take the remainder this result leaves when again divided by 11', ' thus we would like to use as our secondary hash function h2(n) = (k/11)%11', ' however, this has yet another problem: it might give zero at some point, and we obviously cannot test ‘every zeroth location’', ' an easy solution is to simply make the secondary hash function one if the above would evaluate to zero, that is:  (cid:26) (k/11)%11 if (k/11)%11 (cid:54)= 0,  h2(n) =  1  otherwise', '  the values of this for our example set of keys are given in the following table:  code h2(x1x2x3)  phl ory gcm hkg gla akl fra lax dca bhx  4  1  1  3  9  2  6  7  2  3  we can then proceed from the situation we were in when the ﬁrst collision occurred:  phl  gcm  ory  with hkg the next key to insert, which gives a collision with phl', ' since h2(hkg) = 3 we now try every third location to the left in order to ﬁnd a free slot:  hkg  phl  gcm  ory  note that this did not create a block', ' when we now try to insert gla, we once again ﬁnd its primary location blocked by ory', ' since h2(gla) = 9, we now try every ninth location', ' counting to the left from ory, that gets us (starting again from the back when we reach the ﬁrst slot) to the last location overall:  hkg  phl  gcm  ory  gla ', '  note that we still have not got any blocks, which is good', ' further note that most keys which share the same primary location with ory and gla will follow a diﬀerent route when trying to ﬁnd an empty slot, thus avoiding primary clustering', ' here is the result when ﬁlling the table with the remaining keys given:  hkg dca  phl fra gcm akl ory lax gla  our example is too small to show convincingly that this method also avoids secondary clus- tering, but in general it does', '  it is clear that the trivial secondary hash function h2(n) = 1 reduces this approach to that of linear probing', ' it is also worth noting that, in both cases, proceeding to secondary positions to the left is merely a convention – it could equally well be to the right – but obviously it has to be made clear which direction has been chosen for a particular hash table', '  search complexity', ' the eﬃciency of double hashing is even more diﬃcult to compute than that of linear probing, and therefore we shall just give the results without a derivation', ' with load factor λ, a successful search requires (1/λ) ln(1/(1 − λ)) comparisons on average, and an unsuccessful one requires 1/(1 − λ)', ' note that it is the natural logarithm (to base e = 2', '71828 ', ' ', ' ', ') that occurs here, rather than the usual logarithm to base 2', ' thus, the hash table time complexity for search is again constant, i', 'e', ' o(1)', '  95  \x0c10', '10 choosing good hash functions  in principle, any convenient function can be used as a primary hash function', ' however, what is important when choosing a good hash function is to make sure that it spreads the space of possible keys onto the set of hash table indices as evenly as possible, or more collisions than necessary will occur', ' secondly, it is advantageous if any potential clusters in the space of possible keys are broken up (something that the remainder in a division will not do), because in that case we could end up with a ‘continuous run’ and associated clustering problems in the hash table', ' therefore, when deﬁning hash functions of strings of characters, it is never a good idea to make the last (or even the ﬁrst) few characters decisive', '  when choosing secondary hash functions, in order to avoid primary clustering, one has to make sure that diﬀerent keys with the same primary position give diﬀerent results when the secondary hash function is applied', ' secondly, one has to be careful to ensure that the secondary hash function cannot result in a number which has a common divisor with the size of the hash table', ' for example, if the hash table has size 10, and we get a secondary hash function which gives 2 (or 4, 6 or 8) as a result, then only half of the locations will be checked, which might result in failure (an endless loop, for example) while the table is still half empty', ' even for large hash tables, this can still be a problem if the secondary hash keys can be similarly large', ' a simple remedy for this is to always make the size of the hash table a prime number', '  10', '11 complexity of hash tables  we have already seen that insert, search and delete all have o(1) time complexity if the load factor of the hash table is kept reasonably low, e', 'g', ' below 0', '5, but having higher load factors can considerably slow down the operations', '  the crucial search time complexity of a particular form of hash table is determined by counting the average number of location checks that are needed when searching for items in the table when it has a particular load factor, and that will depend on whether the item is found', ' the following table shows the average number of locations that need to be checked to conduct successful and unsuccessful searches in hash tables with diﬀerent collision handling strategies, depending on the load factor given in the top row', ' it shows how the diﬀerent approaches and cases vary diﬀerently as the table becomes closer to fully loaded', '  strategy successful search direct chaining linear probing double hashing unsuccessful search direct chaining linear probing double hashing  0', '10  0', '25  0', '50  0', '75  0', '90  0', '99  1', '05 1', '06 1', '05  0', '10 1', '12 1', '11  1', '12 1', '17 1', '15  0', '25 1', '39 1', '33  1', '25 1', '50 1', '39  0', '50 2', '50 2', '00  1', '37 2', '50 1', '85  0', '75 8', '50 4', '00  1', '45 5', '50 2', '56  1', '48 50', '50 4', '65  0', '90 50', '50 10', '00  0', '99 5000', '00 100', '00  it also shows the considerable advantage that double hashing has over linear probing, partic- ularly when the load factors become large', ' whether or not double hashing is preferable to  96  \x0cdirect chaining (which appears far superior, but is generally more complex to implement and maintain) is dependent on the circumstances', '  the following table shows a comparison of the average time complexities for the diﬀerent  possible implementations of the table interface:  sorted array balanced bst hash table  insert search o(n) o(log2 n) o(log2 n) o(log2 n) o(log2 n) o(1)  delete o(n)  o(1)  o(1)  traverse o(n) o(n) o(nlog2 n)  hash tables are seen to perform rather well: the complexity of searching, updating and retrieving are all independent of table size', ' in practice, however, when deciding what approach to use, it will depend on the mix of operations typically performed', ' for example, lots of repeated deletions and insertions can cause eﬃciency problems with some hash table strategies, as explained above', ' to give a concrete example, if there are 4096 entries in a balanced binary search tree, it takes on average 12', '25 comparisons to complete a successful search', ' on the other hand, we can need as few as 1', '39 comparisons if we use a hash table, provided that we keep its load factor below 50 percent', ' of course, despite their time advantage, we should never forget that hash tables have a considerable disadvantage in terms of the memory required to implement them eﬃciently', '  97  \x0cchapter 11  graphs  often it is useful to represent information in a more general graphical form than considered so far, such as the following representation of the distances between towns:  with similar structures (maybe leaving out the distances, or replacing them by something else), we could represent many other situations, like an underground tunnel network, or a network of pipes (where the number label might give the pipe diameters), or a railway map, or an indication of which cities are linked by ﬂights, or ferries, or political alliances', ' even if we assume it is a network of paths or roads, the numbers do not necessarily have to represent distances, they might be an indication of how long it takes to cover the distance in question on foot, so a given distance up a steep hill would take longer than on even ground', '  there is much more that can be done with such a picture of a situation than just reading oﬀ which place is directly connected with another place: for example, we can ask ourselves  98  edinburghnewcastlemanchesterlondonexeter110glasgow44215swansea80157117286168birmingham119198\x0cwhether there is a way of getting from a to b at all, or what is the shortest path, or what would be the shortest set of pipes connecting all the locations', ' there is also the famous travelling salesman problem which involves ﬁnding the shortest route through the structure that visits each city precisely once', '  11', '1 graph terminology  the kind of structure in the above ﬁgure is known formally as a graph', ' a graph consists of a series of nodes (also called vertices or points), displayed as nodes, and edges (also called lines, links or, in directed graphs, arcs), displayed as connections between the nodes', ' there exists quite a lot of terminology that allows us to specify graphs precisely:  a graph is said to be simple if it has no self-loops (i', 'e', ', edges connected at both ends to the same vertex) and no more than one edge connecting any pair of vertices', ' the remainder of this chapter will assume that, which is suﬃcient for most practical applications', '  if there are labels on the edges (usually non-negative real numbers), we say that the graph is weighted ', ' we distinguish between directed and undirected graphs', ' in directed graphs (also called digraphs), each edge comes with one or two directions, which are usually indicated by arrows', ' think of them as representing roads, where some roads may be one-way only', ' or think of the associated numbers as applying to travel in one way only: such as going up a hill which takes longer than coming down', ' an example of an unweighted digraph is:  and an example of a weighted digraph, because it has labels on its edges, is:  in undirected graphs, we assume that every edge can be viewed as going both ways, that is, an edge between a and b goes from a to b as well as from b to a', ' the ﬁrst graph given at the beginning of this chapter is weighted and undirected', '  a path is a sequence of nodes or vertices v1, v2, ', ' ', ' ', ' , vn such that vi and vi+1 are connected by an edge for all 1 ≤ i ≤ n − 1', ' note that in a directed graph, the edge from vi to vi+1 is the one which has the corresponding direction', ' a circle is a non-empty path whose ﬁrst vertex is the same as its last vertex', ' a path is simple if no vertex appears on it twice (with the exception of a circle, where the ﬁrst and last vertex may be the same – this is because we have to ‘cut open’ the circle at some point to get a path, so this is inevitable)', '  99  abcde422613112232edcab\x0can undirected graph is connected if every pair of vertices has a path connecting them', ' for directed graphs, the notion of connectedness has two distinct versions: we say that a digraph is weakly connected if for every two vertices a and b there is either a path from a to b or a path from b to a', ' we say it is strongly connected if there are paths leading both ways', ' so, in a weakly connected digraph, there may be two vertices i and j such that there exists no path from i to j', '  a graph clearly has many properties similar to a tree', ' in fact, any tree can be viewed as a simple graph of a particular kind, namely one that is connected and contains no circles', ' because a graph, unlike a tree, does not come with a natural ‘starting point’ from which there is a unique path to each vertex, it does not make sense to speak of parents and children in a graph', ' instead, if two vertices a and b are connected by an edge e, we say that they are neighbours, and the edge connecting them is said to be incident to a and b', ' two edges that have a vertex in common (for example, one connecting a and b and one connecting b and c) are said to be adjacent', '  11', '2  implementing graphs  all the data structures we have considered so far were designed to hold certain information, and we wanted to perform certain actions on them which mostly centred around inserting new items, deleting particular items, searching for particular items, and sorting the collection', ' at no time was there ever a connection between all the items represented, apart from the order in which their keys appeared', ' moreover, that connection was never something that was inherent in the structure and that we therefore tried to represent somehow – it was just a property that we used to store the items in a way which made sorting and searching quicker', ' now, on the other hand, it is the connections that are the crucial information we need to encode in the data structure', ' we are given a structure which comes with speciﬁed connections, and we need to design an implementation that eﬃciently keeps track of them', '  array-based implementation', ' the ﬁrst underlying idea for array-based implementations is that we can conveniently rename the vertices of the graph so that they are labelled by non-negative integer indices, say from 0 to n − 1, if they do not have these labels already', ' however, this only works if the graph is given explicitly, that is, if we know in advance how many vertices there will be, and which pairs will have edges between them', ' then we only need to keep track of which vertex has an edge to which other vertex, and, for weighted graphs, what the weights on the edges are', ' for unweighted graphs, we can do this quite easily in an n × n two-dimensional binary array adj, also called a matrix , the so-called adjacency matrix ', ' in the case of weighted graphs, we instead have an n × n weight matrix weights', ' the array/matrix representations for the two example graphs shown above are then:  a b c d e 4 2 0 0 0 0 0 1 0 1 0 1 1 1 0 0 0 0  3 1 0 0 0 0  1 1 0 0 0 0  a 0 b 1 c 2 d 3 e 4  3  a b c d e 1 0 4 2 1 ∞ 4 ∞ 0 a 0 6 b 1 0 2 2 1 2 c 2 ∞ 3 1 d 3 ∞ ∞ ∞ 0 0 2 e 4 ∞ ∞ 3  2 0  100  \x0cin the ﬁrst case, for the unweighted graph, a ‘0’ in position adj[i][j] reads as false, that is, there is no edge from the vertex i to the vertex j', ' a ‘1’, on the other hand, reads as true, indicating that there is an edge', ' it is often useful to use boolean values here, rather than the numbers 0 and 1, because it allows us to carry out operations on the booleans', ' in the second case, we have a weighted graph, and we have the real-valued weights in the matrix instead, using the inﬁnity symbol ∞ to indicate when there is no edge', '  for an undirected graph, if there is a 1 in the ith column and the jth row, we know that there is an edge from vertex i to the vertex with the number j, which means there is also an edge from vertex j to vertex i', ' this means that adj[i][j] == adj[j][i] will hold for all i and j from 0 to n − 1, so there is some redundant information here', ' we say that such a matrix is symmetric – it equals its mirror image along the main diagonal', '  mixed implementation', ' there is a potential problem with the adjacency/weight matrix representation: if the graph has very many vertices, the associated array will be extremely large (e', 'g', ', 10,000 entries are needed if the graph has just 100 vertices)', ' then, if the graph is sparse (i', 'e', ', has relatively few edges), the adjacency matrix contains many 0s and only a few 1s, and it is a waste of space to reserve so much memory for so little information', '  a solution to this problem is to number all the vertices as before, but, rather than using a two-dimensional array, use a one-dimensional array that points to a linked list of neighbours for each vertex', ' for example, the above weighted graph can be represented as follows, with each triple consisting of a vertex name, connection weight and pointer to the next triple:  if there are very few edges, we will have very short lists at each entry of the array, thus sav- ing space over the adjacency/weight matrix representation', ' this implementation is using so-called adjacency lists', ' note that if we are considering undirected graphs, there is still a certain amount of redundancy in this rep- resentation, since every edge is represented twice, once in each list corresponding to the two vertices it connects', ' in java, this could be accomplished with something like:  class graph {  vertex[] heads; private class vertex {  int name; double weight; vertex next; ', '', '', '//methods for vertices  } ', '', '', '//methods for graphs  }  101  01234113402223246133241412332\x0cpointer-based implementation', ' the standard pointer -based implementation of binary trees, which is essentially a generalization of linked lists, can be generalized for graphs', ' in a language such as java, a class graph might have the following as an internal class:  class vertex {  string name; vertex[] neighbours; double[] weights;  }  when each vertex is created, an array neighbours big enough to accommodate (pointers to) all its neighbours is allocated, with (for weighted graphs) an equal sized array weights to accommodate the associated weights', ' we then place the neighbours of each vertex into those arrays in some arbitrary order', ' any entries in the neighbours array that are not needed will hold a null pointer as usual', ' for example, the above weighted graph would be represented as follows, with each weight shown following the associated pointer:  11', '3 relations between graphs  many important theorems about graphs rely on formal deﬁnitions of the relations between them, so we now deﬁne the main relevant concepts', ' two graphs are said to be isomorphic if they contain the same number of vertices with the same pattern of adjacency, i', 'e', ' there is a bijection between their vertices which preserves the adjacency relations', ' a subgraph of a graph g is deﬁned as any graph that has a vertex set which is a subset of that of g, with adjacency relations which are a subset of those of g', ' conversely, a supergraph of a graph g is deﬁned as any graph which has g as a subgraph', ' finally, a graph g is said to contain another graph h if there exists a subgraph of g that is either h or isomorphic to h', '  a subdivision of an edge e with endpoints u and v is simply the pair of edges e1, with endpoints u and w, and e2, with endpoints w and v, for some new vertex w', ' the reverse operation of smoothing removes a vertex w with exactly two edges e1 and e2, leaving an edge e connecting the two adjacent vertices u and v:  102  02341413212316222\x0ca subdivision of a graph g can be deﬁned as a graph resulting from the subdivision of edges in g', ' two graphs g and h can then be deﬁned as being homeomorphic if there is a graph isomorphism from some subdivision of g to some subdivision of h', '  an edge contraction removes an edge from a graph and merges the two vertices previously connected by it', ' this can lead to multiple edges between a pair of vertices, or self-loops connecting a vertex to itself', ' these are not allowed in simple graphs, in which case some edges may need to be deleted', ' then an undirected graph h is said to be a minor of another undirected graph g if a graph isomorphic to h can be obtained from g by contracting some edges, deleting some edges, and deleting some isolated vertices', '  11', '4 planarity  a planar graph is a graph that can be embeded in a plane', ' in other words, it can be drawn on a sheet of paper in such a way that no edges cross each other', ' this is important in applications such as printed circuit design', '  note that it is clearly possible for planar graphs to be drawn in such a way that their edges do cross each other, but the crucial thing is that they can be transformed (by moving vertices and/or deforming the edges) into a form without any edges crossing', ' for example, the following three diagrams all represent the same planar graph:  this graph is the fully connected graph with four vertices, known as k4', ' clearly all sub-graphs of this will also be planar', '  it is actually quite diﬃcult to formulate general algorithms for determining whether a given graph is planar', ' for small graphs, it is easy to check systematically that there are no possible vertex repositionings or edge deformations that will bring the graph into explicitly planar form', ' two slightly larger graphs than k4 that can be shown to be non-planar in this way are the fully connected graph with ﬁve vertices, known as k5, and the graph with three vertices fully connected to three other vertices, known as k3,3:  clearly, any larger graph that contains one of these two non-planar graphs as a subgraph must also be non-planar iteslf, and any subdivision or smoothing of edges will have no eﬀect  103  \x0con the planarity', ' in fact, it can be proved that these two graphs form the basis of some useful theorems about planarity', ' the most well-known of these is kuratowski’s theorem which states that “a ﬁnite graph is planar if and only if it does not contain a subgraph that is homeomorphic to, or a subdivision of, k5 or k3,3”', ' another, based on the concept of minors, is wagner’s theorem which states that “a ﬁnite graph is planar if and only if it does not have k5 or k3,3 as a minor”', '  a good general approach for testing planarity is therefore to search for subgraphs of the given graph that can be transformed into k5 or k3,3', ' this is not entirely straightforward, but algorithms do exist which allow a graph with n vertices to be tested for planarity with time complexity o(n)', ' exercise: ﬁnd out exactly how these algorithms work', '  11', '5 traversals – systematically visiting all vertices  in order to traverse a graph, i', 'e', ' systematically visit all its vertices, we clearly need a strategy for exploring graphs which guarantees that we do not miss any edges or vertices', ' because, unlike trees, graphs do not have a root vertex, there is no natural place to start a traversal, and therefore we assume that we are given, or randomly pick, a starting vertex i', ' there are two strategies for performing graph traversal', '  the ﬁrst is known as breadth ﬁrst traversal : we start with the given vertex i', ' then we visit its neighbours one by one (which must be possible no matter which implementation we use), placing them in an initially empty queue', ' we then remove the ﬁrst vertex from the queue and one by one put its neighbours at the end of the queue', ' we then visit the next vertex in the queue and again put its neighbours at the end of the queue', ' we do this until the queue is empty', '  however, there is no reason why this basic algorithm should ever terminate', ' if there is a circle in the graph, like a, b, c in the ﬁrst unweighted graph above, we would revisit a vertex we have already visited, and thus we would run into an inﬁnite loop (visiting a’s neighbours puts b onto the queue, visiting that (eventually) gives us c, and once we reach c in the queue, we get a again)', ' to avoid this we create a second array done of booleans, where done[j] is true if we have already visited the vertex with number j, and it is false otherwise', ' in the above algorithm, we only add a vertex j to the queue if done[j] is false', ' then we mark it as done by setting done[j] = true', ' this way, we will not visit any vertex more than once, and for a ﬁnite graph, our algorithm is bound to terminate', ' in the example we are discussing, breadth ﬁrst search starting at a might yield: a, b, d, c, e', '  to see why this is called breadth ﬁrst search, we can imagine a tree being built up in this way, where the starting vertex is the root, and the children of each vertex are its neighbours (that haven’t already been visited)', ' we would then ﬁrst follow all the edges emanating from the root, leading to all the vertices on level 1, then ﬁnd all the vertices on the level below, and so on, until we ﬁnd all the vertices on the ‘lowest’ level', '  the second traversal strategy is known as depth ﬁrst traversal : given a vertex i to start from, we now put it on a stack rather than a queue (recall that in a stack, the next item to be removed at any time is the last one that was put on the stack)', ' then we take it from the stack, mark it as done as for breadth ﬁrst traversal, look up its neighbours one after the other, and put them onto the stack', ' we then repeatedly pop the next vertex from the stack, mark it as done, and put its neighbours on the stack, provided they have not been marked as done, just as we did for breadth ﬁrst traversal', ' for the example discussed above, we might (starting from a) get: a, b, c, e, d', ' again, we can see why this is called depth ﬁrst by  104  \x0cformulating the traversal as a search tree and looking at the order in which the items are added and processed', '  note that with both breadth ﬁrst and depth ﬁrst, the order of the vertices depends on the implementation', ' there is no reason why a’s neighbour b should be visited before d in the example', ' so it is better to speak of a result of depth ﬁrst or breadth ﬁrst traversal, rather than of the result', ' note also that the only vertices that will be listed are those in the same connected component as a', ' if we have to ensure that all vertices are visited, we may need to start the traversal process with a number of diﬀerent starting vertices, each time choosing one that has not been marked as done when the previous traversal terminated', '  exercises: write algorithms, in pseudocode, to (1) visit all nodes of a graph, and (2) decide whether a given graph is connected or not', ' for (2) you will actually need two algorithms, one for the strong notion of connectedness, and another for the weak notion', '  11', '6 shortest paths – dijkstra’s algorithm  a common graph based problem is that we have some situation represented as a weighted di- graph with edges labelled by non-negative numbers and need to answer the following question: for two particular vertices, what is the shortest route from one to the other?  here, by “shortest route” we mean a path which, when we add up the weights along its edges, gives the smallest overall weight for the path', ' this number is called the length of the path', ' thus, a shortest path is one with minimal length', ' note that there need not be a unique shortest path, since several paths might have the same length', ' in a disconnected graph there will not be a path between vertices in diﬀerent components, but we can take care of this by using ∞ once again to stand for “no path at all”', '  note that the weights do not necessarily have to correspond to distances; they could, for example, be time (in which case we could speak of “quickest paths”) or money (in which case we could speak of “cheapest paths”), among other possibilities', ' by considering “abstract” graphs in which the numerical weights are left uninterpreted, we can take care of all such situations and others', ' but notice that we do need to restrict the edge weights to be non- negative numbers, because if there are negative numbers and cycles, we can have increasingly long paths with lower and lower costs, and no path with minimal cost', '  applications of shortest-path algorithms include internet packet routing (because, if you send an email message from your computer to someone else, it has to go through various email routers, until it reaches its ﬁnal destination), train-ticket reservation systems (that need to ﬁgure out the best connecting stations), and driving route ﬁnders (that need to ﬁnd an optimum route in some sense)', '  dijkstra’s algorithm', ' in turns out that, if we want to compute the shortest path from a given start node s to a given end node z, it is actually most convenient to compute the shortest paths from s to all other nodes, not just the given node z that we are interested in', ' given the start node, dijkstra’s algorithm computes shortest paths starting from s and ending at each possible node', ' it maintains all the information it needs in simple arrays, which are iteratively updated until the solution is reached', ' because the algorithm, although elegant and short, is fairly complicated, we shall consider it one component at a time', '  overestimation of shortest paths', ' we keep an array d of distances indexed by the vertices', ' the idea is that d[z] will hold the distance of the shortest path from s to z when  105  \x0cthe algorithm ﬁnishes', ' however, before the algorithm ﬁnishes, d[z] is the best overestimate we currently have of the distance from s to z', ' we initially have d[s] = 0, and set d[z] = ∞ for all vertices z other than the start node s', ' then the algorithm repeatedly decreases the overestimates until it is no longer possible to decrease them further', ' when this happens, the algorithm terminates, with each estimate fully constrained and said to be tight', '  improving estimates', ' the general idea is to look systematically for shortcuts', ' suppose that, for two given vertices u and z, it happens that d[u] + weight[u][z] < d[z]', ' then there is a way of going from s to u and then to z whose total length is smaller than the current overestimate d[z] of the distance from s to z, and hence we can replace d[z] by this better estimate', ' this corresponds to the code fragment  if ( d[u] + weight[u][z] < d[z] ) d[z] = d[u] + weight[u][z]  of the full algorithm given below', ' the problem is thus reduced to developing an algorithm that will systematically apply this improvement so that (1) we eventually get the tight estimates promised above, and (2) that is done as eﬃciently as possible', '  dijkstra’s algorithm, version 1', ' the ﬁrst version of such an algorithm is not as eﬃcient as it could be, but it is relatively simple and certainly correct', ' (it is always a good idea to start with an ineﬃcient simple algorithm, so that the results from it can be used to check the operation of a more complex eﬃcient algorithm', ') the general idea is that, at each stage of the algorithm’s operation, if an entry d[u] of the array d has the minimal value among all the values recorded in d, then the overestimate d[u] must actually be tight, because the improvement algorithm discussed above cannot possibly ﬁnd a shortcut', '  the following algorithm implements that idea:  // input: a directed graph with weight matrix ‘weight’ and // // output: an array ‘d’ of distances as explained above', '  a start vertex ‘s’', '  // we begin by buiding the distance overestimates', '  d[s] = 0  // the shortest path from s to itself has length zero', '  for ( each vertex z of the graph ) {  if ( z is not the start vertex s )  d[z] = infinity  // this is certainly an overestimate', '  // we use an auxiliary array ‘tight’ indexed by the vertices, // that records for which nodes the shortest path estimates // are ‘‘known’’ to be tight by the algorithm', '  }  }  for ( each vertex z of the graph ) {  tight[z] = false  106  \x0c// we now repeatedly update the arrays ‘d’ and ‘tight’ until // all entries in the array ‘tight’ hold the value true', '  repeat as many times as there are vertices in the graph {  find a vertex u with tight[u] false and minimal estimate d[u] tight[u] = true for ( each vertex z adjacent to u )  if ( d[u] + weight[u][z] < d[z] ) d[z] = d[u] + weight[u][z]  // lower overestimate exists', '  }  // at this point, all entries of array ‘d’ hold tight estimates', '  it is clear that when this algorithm ﬁnishes, the entries of d cannot hold under-estimates of the lengths of the shortest paths', ' what is perhaps not so clear is why the estimates it holds are actually tight, i', 'e', ' are the minimal path lengths', ' in order to understand why, ﬁrst notice that an initial sub-path of a shortest path is itself a shortest path', ' to see this, suppose that you wish to navigate from a vertex s to a vertex z, and that the shortest path from s to z happens to go through a certain vertex u', ' then your path from s to z can be split into two paths, one going from s to u (an initial sub-path) and the other going from u to z (a ﬁnal sub-path)', ' given that the whole, unsplit path is a shortest path from s to z, the initial sub-path has to be a shortest path from s to u, for if not, then you could shorten your path from s to z by replacing the initial sub-path to u by a shorter path, which would not only give a shorter path from s to u but also from s to the ﬁnal destination z', ' now it follows that for any start vertex, there is a tree of shortest paths from that vertex to all other vertices', ' the reason is that shortest paths cannot have cycles', ' implicitly, dijkstra’s algorithm constructs this tree starting from the root, that is, the start vertex', '  if, as tends to be the case in practice, we also wish to compute the route of shortest path, rather than just its length, we also need to introduce a third array pred to keep track of the ‘predecessor’ or ‘previous vertex’ of each vertex, so that the path can be followed back from the end point to the start point', ' the algorithm can clearly also be adapted to work with non-weighted graphs by assigning a suitable weight matrix of 1s for connected vertices and 0s for non-connected vertices', '  the time complexity of this algorithm is clearly o(n2) where n is the number of vertices,  since there are operations of o(n) nested within the repeat of o(n)', '  a simple example', ' suppose we want to compute the shortest path from a (node 0) to e (node 4) in the weighted graph we looked at before:  107  422613112232edcab\x0ca direct implementation of the above algorithm, with some code added to print out the status of the three arrays at each intermediate stage, gives the following output, in which“oo” is used to represent the inﬁnity symbol “∞”:  computing shortest paths from a  b  |a  c --------+--------------------------------------- d tight pred', '  |0 |no |none  oo no none  oo no none  oo no none  oo no none  e  d  vertex a has minimal estimate, and so is tight', '  b  |a  c --------+--------------------------------------- d tight pred', '  |0 |yes |none  oo no none  oo no none  4 no a  1 no a  e  d  vertex b has minimal estimate, and so is tight', '  neighbour b has estimate decreased from oo to 1 taking a shortcut via a', ' neighbour d has estimate decreased from oo to 4 taking a shortcut via a', '  neighbour a is already tight', ' neighbour c has estimate decreased from oo to 3 taking a shortcut via b', ' neighbour d has estimate decreased from 4 to 3 taking a shortcut via b', ' neighbour e has estimate decreased from oo to 7 taking a shortcut via b', '  b  |a  c --------+--------------------------------------- 3 d no tight b pred', '  |0 |yes |none  1 yes a  7 no b  3 no b  d  e  vertex c has minimal estimate, and so is tight', '  neighbour b is already tight', ' neighbour d has estimate unchanged', ' neighbour e has estimate decreased from 7 to 4 taking a shortcut via c', '  b  |a  c --------+--------------------------------------- 3 d yes tight b pred', '  |0 |yes |none  1 yes a  4 no c  3 no b  d  e  108  \x0cvertex d has minimal estimate, and so is tight', '  neighbour e has estimate unchanged', '  b  |a  c --------+--------------------------------------- 3 d yes tight b pred', '  |0 |yes |none  3 yes b  1 yes a  4 no c  e  d  vertex e has minimal estimate, and so is tight', '  neighbour c is already tight', ' neighbour d is already tight', '  b  |a  c --------+--------------------------------------- 3 d yes tight b pred', '  |0 |yes |none  4 yes c  3 yes b  1 yes a  d  e  end of dijkstra’s computation', '  a shortest path from a to e is: a b c e', '  once it is clear what is happening at each stage, it is usually more convenient to adopt a shorthand notation that allows the whole process to be represented in a single table', ' for example, using a “*” to represent tight, the distance, status and predecessor for each node at each stage of the above example can be listed more concisely as follows:  a  c  b  d  stage | -------+------------------------------------------------ 1 2 3 4 5 6  | 0 | 0 * | 0 * | 0 * | 0 * | 0 *  oo a 4 b 3 b 3 3 * b 3 * b  oo oo b 7 c 4 4 c 4 * c  oo oo 3 b 3 * b 3 * b 3 * b  oo 1 a 1 * a 1 * a 1 * a 1 * a  e  a shortest path from a to e is: a b c e', '  dijkstra’s algorithm, version 2', ' the time complexity of dijkstra’s algorithm can be improved by making use of a priority queue (e', 'g', ', some form of heap) to keep track of which node’s distance estimate becomes tight next', ' here it is convenient to use the convention that lower numbers have higher priority', ' the previous algorithm then becomes:  109  \x0c// input: a directed graph with weight matrix ‘weight’ and // // output: an array ‘d’ of distances as explained above', '  a start vertex ‘s’', '  // we begin by buiding the distance overestimates', '  d[s] = 0  // the shortest path from s to itself has length zero', '  for ( each vertex z of the graph ) {  if ( z is not the start vertex s )  d[z] = infinity  // this is certainly an overestimate', '  }  // then we set up a priority queue based on the overestimates', '  create a priority queue containing all the vertices of the graph, with the entries of d as the priorities  // then we implicitly build the path tree discussed above', '  while ( priority queue is not empty ) {  // the next vertex of the path tree is called u', ' u = remove vertex with smallest priority from queue for ( each vertex z in the queue which is adjacent to u ) {  if ( d[u] + weight[u][z] < d[z] ) {  d[z] = d[u] + weight[u][z] change the priority of vertex z in queue to d[z]  // lower overestimate exists', '  }  }  }  // at this point, all entries of array ‘d’ hold tight estimates', '  if the priority queue is implemented as a binary or binomial heap, initializing d and creating the priority queue both have complexity o(n), where n is the number of vertices of the graph, and that is negligible compared to the rest of the algorithm', ' then removing vertices and changing the priorities of elements in the priority queue require some rearrangement of the heap tree by “bubbling up”, and that takes o(log2 n) steps, because that is the maximum height of the tree', ' removals happen o(n) times, and priority changes happen o(e) times, where e is the number of edges in the graph, so the cost of maintaining the queue and updating d is o((e + n)log2 n)', ' thus, the total time complexity of this form of dijkstra’s algorithm is o((e + n)log2 n)', ' using a fibonacci heap for the priority queue allows priority updates of o(1) complexity, improving the overall complexity to o(e + nlog2 n)', '  in a fully connected graph, the number of edges e will be o(n2), and hence the time complexity of this algorithm is o(n2log2 n) or o(n2) depending on which kind of priority queue is used', ' so, in that case, the time complexity is actually greater than or equal to the previous simpler o(n2) algorithm', ' however, in practice, many graphs tend to be much more  110  \x0csparse with e = o(n)', ' that is, there are usually not many more edges than vertices, and in this case the time complexity for both priority queue versions is o(nlog2 n), which is a clear improvement over the previous o(n2) algorithm', '  11', '7 shortest paths – floyd’s algorithm  if we are not only interested in ﬁnding the shortest path from one speciﬁc vertex to all the others, but the shortest paths between every pair of vertices, we could, of course, apply dijkstra’s algorithm to every starting vertex', ' but there is actually a simpler way of doing this, known as floyd’s algorithm', ' this maintains a square matrix ‘distance’ which contains the overestimates of the shortest paths between every pair of vertices, and systematically decreases the overestimates using the same shortcut idea as above', ' if we also wish to keep track of the routes of the shortest paths, rather than just their lengths, we simply introduce a second square matrix ‘predecessor’ to keep track of all the ‘previous vertices’', '  in the algorithm below, we attempt to decrease the estimate of the distance from each vertex s to each vertex z by going systematically via each possible vertex u to see whether that is a shortcut; and if it is, the overestimate of the distance is decreased to the smaller overestimate, and the predecessor updated:  // store initial estimates and predecessors', '  for ( each vertex s ) {  for ( each vertex z ) {  distance[s][z] = weight[s][z] predecessor[s][z] = s  }  }  // improve them by considering all possible shortcuts u', '  for ( each vertex u ) {  for ( each vertex s ) {  for ( each vertex z ) {  if ( distance[s][u]+distance[u][z] < distance[s][z] ) {  distance[s][z] = distance[s][u]+distance[u][z] predecessor[s][z] = predecessor[u][z]  }  }  }  }  as with dijkstra’s algorithm, this can easily be adapted to the case of non-weighted graphs by assigning a suitable weight matrix of 0s and 1s', '  the time complexity here is clearly o(n3), since it involves three nested for loops of o(n)', ' this is the same complexity as running the o(n2) dijkstra’s algorithm once for each of the n possible starting vertices', ' in general, however, floyd’s algorithm will be faster than dijkstra’s, even though they are both in the same complexity class, because the former performs fewer  111  \x0cinstructions in each run through the loops', ' however, if the graph is sparse with e = o(n), then multiple runs of dijkstra’s algorithm can be made to perform with time complexity o(n2log2 n), and be faster than floyd’s algorithm', '  a simple example', ' suppose we want to compute the lengths of the shortest paths between all vertices in the following undirected weighted graph:  e a b c d e  e a b c d e  start  a :  b :  c :  we start with distance matrix based on the connection weights, and trivial predecessors:  c 14  a 0 1 14 ∞ 0 4 ∞ 8 10  d e b 4 ∞ 1 0 ∞ ∞ 2 10 1 0  a b c d e ∞ 2  8 0 1  a a b c d e  b a b c d e  c a b c d e  d a b c d e  a b c d e  then for each vertex in turn we test whether a shortcut via that vertex reduces any of the distances, and update the distance and predecessor arrays with any reductions found', ' the ﬁve steps, with the updated entries in quotes, are as follows::  b a 1 0 a 0 1 b ‘15’ 14 c d ‘5’ 4 e ∞ 2  c 14 ‘15’ 0 8 10  d e 4 ∞ 2 ‘5’ 10 8 1 0 0 1  a 0 1 14 4 ‘3’  a 0 1 14 4 3  b 1 0 15 5 2  b 1 0 15 5 2  c 14 15 0 8 10  c 14 15 0 8 10  d 4 5 8 0 1  d 4 5 8 0 1  a b c d e  a b c d e  e ‘3’ 2 10 1 0  e 3 2 10 1 0  112  c b a a a a ‘a’ b b c c ‘a’ d ‘a’ d e e e  d a ‘a’ c d e  a a b c d ‘b’  a a b c d b  b a b a a e  b a b a a e  c a a c d e  c a a c d e  d e a ‘b’ b a c c d d e e  d a a c d e  e b b c d e  a b c d e  a b c d e  a b c d e  \x0cd :  e :  a 0 1  a b c ‘12’ d e  4 3  a 0 1 12 4 3  a b c d e  b 1 0 ‘13’ 5 2  b 1 0 ‘11’ ‘3’ 2  c ‘12’ ‘13’ 0 8 ‘9’  c 12 ‘11’ 0 8 9  d 4 5 8 0 1  d 4 ‘3’ 8 0 1  e 3 2 ‘9’ 1 0  e 3 2 9 1 0  d c b a a ‘d’ a a ‘d’ a b b c c ‘d’ a d d a d e ‘d’ e b  d c b a d a a a d ‘e’ b b c c d ‘e’ d d ‘e’ d e d e b  e b b ‘d’ d e  e b b d d e  a b c d e  a b c d e  the algorithm ﬁnishes with the matrix of shortest distances and the matrix of associated predecessors', ' so the shortest distance from c to b is 11, and the predecessors of b are e, then d, then c, giving the path c d e b', ' note that updating a distance does not necessarily mean updating the associated predecessor – for example, when introducing d as a shortcut between c and b, the predecessor of b remains a', '  11', '8 minimal spanning trees  we now move on to another common graph-based problem', ' suppose you have been given a weighted undirected graph such as the following:  we could think of the vertices as representing houses, and the weights as the distances between them', ' now imagine that you are tasked with supplying all these houses with some commodity such as water, gas, or electricity', ' for obvious reasons, you will want to keep the amount of digging and laying of pipes or cable to a minimum', ' so, what is the best pipe or cable layout that you can ﬁnd, i', 'e', ' what layout has the shortest overall length?  obviously, we will have to choose some of the edges to dig along, but not all of them', ' for example, if we have already chosen the edge between a and d, and the one between b and d, then there is no reason to also have the one between a and b', ' more generally, it is clear that we want to avoid circles', ' also, assuming that we have only one feeding-in point (it is of no importance which of the vertices that is), we need the whole layout to be connected ', ' we have seen already that a connected graph without circles is a tree', '  113  abcdef1563664255\x0chence, what we are looking for is a minimal spanning tree of the graph', ' a spanning tree of a graph is a subgraph that is a tree which connects all the vertices together, so it ‘spans’ the original graph but using fewer edges', ' here, minimal refers to the sum of all the weights of the edges contained in that tree, so a minimal spanning tree has total weight less than or equal to the total weight of every other spanning tree', ' as we shall see, there will not necessarily be a unique minimal spanning tree for a given graph', '  observations concerning spanning trees', ' for the other graph algorithms we have cov- ered so far, we started by making some observations which allowed us to come up with an idea for an algorithm, as well as a strategy for formulating a proof that the algorithm did indeed perform as desired', ' so, to come up with some ideas which will allow us to develop an algorithm for the minimal spanning tree problem, we shall need to make some observations about minimal spanning trees', ' let us assume, for the time being, that all the weights in the above graph were equal, to give us some idea of what kind of shape a minimal spanning tree might have under those circumstances', ' here are some examples:  we can immediately notice that their general shape is such that if we add any of the remaining edges, we would create a circle', ' then we can see that going from one spanning tree to another can be achieved by removing an edge and replacing it by another (to the vertex which would otherwise be unconnected) such that no circle is created', ' these observations are not quite suﬃcient to lead to an algorithm, but they are good enough to let us prove that the algorithms we ﬁnd do actually work', '  greedy algorithms', ' we say that an algorithm is greedy if it makes its decisions based only on what is best from the point of view of ‘local considerations’, with no concern about how the decision might aﬀect the overall picture', ' the general idea is to start with an approximation, as we did in dijkstra’s algorithm, and then reﬁne it in a series of steps', ' the algorithm is greedy in the sense that the decision at each step is based only on what is best for that next step, and does not consider how that will aﬀect the quality of the ﬁnal overall solution', ' we shall now consider some greedy approaches to the minimal spanning tree problem', '  prim’s algorithm – a greedy vertex-based approach', ' suppose that we already have a spanning tree connecting some set of vertices s', ' then we can consider all the edges which connect a vertex in s to one outside of s, and add to s one of those that has minimal weight', ' this cannot possibly create a circle, since it must add a vertex not yet in s', ' this process can be repeated, starting with any vertex to be the sole element of s, which is a trivial minimal spanning tree containing no edges', ' this approach is known as prim’s algorithm', '  when implementing prim’s algorithm, one can use either an array or a list to keep track of the set of vertices s reached so far', ' one could then maintain another array or list closest which, for each vertex i not yet in s, keeps track of the vertex in s closest to i', ' that is, the  114  \x0cvertex in s which has an edge to i with minimal weight', ' if closest also keeps track of the weights of those edges, we could save time, because we would then only have to check the weights mentioned in that array or list', '  for the above graph, starting with s = {a}, the tree is built up as follows:  it is slightly more challenging to produce a convincing argument that this algorithm really works than it has been for the other algorithms we have seen so far', ' it is clear that prim’s algorithm must result in a spanning tree, because it generates a tree that spans all the vertices, but it is not obvious that it is minimal', ' there are several possible proofs that it is, but none are straightforward', ' the simplest works by showing that the set of all possible minimal spanning trees xi must include the output of prim’s algorithm', '  let y be the output of prim’s algorithm, and x1 be any minimal spanning tree', ' the  following illustrates such a situation:  we don’t actually need to know what x1 is – we just need to know the properties it must satisfy, and then systematically work through all the possibilities, showing that y is a minimal spanning tree in each case', ' clearly, if x1 = y , then prim’s algorithm has generated a minimal spanning tree', ' otherwise, let e be the ﬁrst edge added to y that is not in x1', ' then, since x1 is a spanning tree, it must include a path connecting the two endpoints of e, and because circles are not allowed, there must be an edge in x1 that is not in y , which we can call f ', ' since prim’s algorithm added e rather than f , we know weight(e) ≤ weight(f )', ' then create tree x2 that is x1 with f replaced by e', ' clearly x2 is connected, has the same number of edges as x1, spans all the vertices, and has total weight no greater than x1, so it must also  115  abefcd1abefcd14abefcd142abefcd1425abefcd14253\x0cbe a minimal spanning tree', ' now we can repeat this process until we have replaced all the edges in x1 that are not in y , and we end up with the minimal spanning tree xn = y , which completes the proof that y is a minimal spanning tree', '  the time complexity of the standard prim’s algorithm is o(n2) because at each step we need to choose a vertex to add to s, and then update the closest array, not dissimilar to the simplest form of dijkstra’s algorithm', ' however, as with dijkstra’s algorithm, a binary or binomial heap based priority queue can be used to speed things up by keeping track of which is the minimal weight vertex to be added next', ' with an adjacency list representation, this can bring the complexity down to o((e + n)log2 n)', ' finally, using the more sophisticated fibonacci heap for the priority queue can improve this further to o(e + nlog2 n)', ' thus, using the optimal approach in each case, prim’s algorithm is o(nlog2 n) for sparse graphs that have e = o(n), and o(n2) for highly connected graphs that have e = o(n2)', '  just as with floyd’s versus dijkstra’s algorithm, we should consider whether it eally is necessary to process every vertex at each stage, because it could be suﬃcient to only check actually existing edges', ' we therefore now consider an alternative edge-based strategy:  kruskal’s algorithm – a greedy edge-based approach', ' this algorithm does not con- sider the vertices directly at all, but builds a minimal spanning tree by considering and adding edges as follows: assume that we already have a collection of edges t ', ' then, from all the edges not yet in t , choose one with minimal weight such that its addition to t does not produce a circle, and add that to t ', ' if we start with t being the empty set, and continue until no more edges can be added, a minimal spanning tree will be produced', ' this approach is known as kruskal’s algorithm', '  for the same graph as used for prim’s algorithm, this algorithm proceeds as follows:  in practice, kruskal’s algorithm is implemented in a rather diﬀerent way to prim’s algorithm', ' the general idea of the most eﬃcient approaches is to start by sorting the edges according to their weights, and then simply go through that list of edges in order of increasing weight, and either add them to t , or reject them if they would produce a circle', ' there are implementations of that which can be achieved with overall time complexity o(elog2 e), which is dominated by the o(elog2 e) complexity of sorting the e edges in the ﬁrst place', '  this means that the choice between prim’s algorithm and kruskal’s algorithm depends on the connectivity of the particular graph under consideration', ' if the graph is sparse, i', 'e', ' the  116  abefcd112123123412345\x0c']